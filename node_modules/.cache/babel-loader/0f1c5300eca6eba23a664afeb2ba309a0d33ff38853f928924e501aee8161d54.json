{"ast":null,"code":"import { gridMap as $1af922eb41e03c8f$export$e6235c0d09b995d0 } from \"./utils.mjs\";\nimport { getFocusableTreeWalker as $j4Qbl$getFocusableTreeWalker, focusSafely as $j4Qbl$focusSafely } from \"@react-aria/focus\";\nimport { scrollIntoViewport as $j4Qbl$scrollIntoViewport, getScrollParent as $j4Qbl$getScrollParent, mergeProps as $j4Qbl$mergeProps } from \"@react-aria/utils\";\nimport { isFocusVisible as $j4Qbl$isFocusVisible } from \"@react-aria/interactions\";\nimport { useRef as $j4Qbl$useRef } from \"react\";\nimport { useLocale as $j4Qbl$useLocale } from \"@react-aria/i18n\";\nimport { useSelectableItem as $j4Qbl$useSelectableItem } from \"@react-aria/selection\";\n\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nfunction $ab90dcbc1b5466d0$export$c7e10bfc0c59f67c(props, state, ref) {\n  let {\n    node: node,\n    isVirtualized: isVirtualized,\n    focusMode = 'child',\n    shouldSelectOnPressUp: shouldSelectOnPressUp,\n    onAction: onAction\n  } = props;\n  let {\n    direction: direction\n  } = (0, $j4Qbl$useLocale)();\n  let {\n    keyboardDelegate: keyboardDelegate,\n    actions: {\n      onCellAction: onCellAction\n    }\n  } = (0, $1af922eb41e03c8f$export$e6235c0d09b995d0).get(state);\n  // We need to track the key of the item at the time it was last focused so that we force\n  // focus to go to the item when the DOM node is reused for a different item in a virtualizer.\n  let keyWhenFocused = (0, $j4Qbl$useRef)(null);\n  // Handles focusing the cell. If there is a focusable child,\n  // it is focused, otherwise the cell itself is focused.\n  let focus = () => {\n    let treeWalker = (0, $j4Qbl$getFocusableTreeWalker)(ref.current);\n    if (focusMode === 'child') {\n      // If focus is already on a focusable child within the cell, early return so we don't shift focus\n      if (ref.current.contains(document.activeElement) && ref.current !== document.activeElement) return;\n      let focusable = state.selectionManager.childFocusStrategy === 'last' ? $ab90dcbc1b5466d0$var$last(treeWalker) : treeWalker.firstChild();\n      if (focusable) {\n        (0, $j4Qbl$focusSafely)(focusable);\n        return;\n      }\n    }\n    if (keyWhenFocused.current != null && node.key !== keyWhenFocused.current || !ref.current.contains(document.activeElement)) (0, $j4Qbl$focusSafely)(ref.current);\n  };\n  let {\n    itemProps: itemProps,\n    isPressed: isPressed\n  } = (0, $j4Qbl$useSelectableItem)({\n    selectionManager: state.selectionManager,\n    key: node.key,\n    ref: ref,\n    isVirtualized: isVirtualized,\n    focus: focus,\n    shouldSelectOnPressUp: shouldSelectOnPressUp,\n    onAction: onCellAction ? () => onCellAction(node.key) : onAction,\n    isDisabled: state.collection.size === 0\n  });\n  let onKeyDownCapture = e => {\n    if (!e.currentTarget.contains(e.target) || state.isKeyboardNavigationDisabled) return;\n    let walker = (0, $j4Qbl$getFocusableTreeWalker)(ref.current);\n    walker.currentNode = document.activeElement;\n    switch (e.key) {\n      case 'ArrowLeft':\n        {\n          // Find the next focusable element within the cell.\n          let focusable = direction === 'rtl' ? walker.nextNode() : walker.previousNode();\n          // Don't focus the cell itself if focusMode is \"child\"\n          if (focusMode === 'child' && focusable === ref.current) focusable = null;\n          e.preventDefault();\n          e.stopPropagation();\n          if (focusable) {\n            (0, $j4Qbl$focusSafely)(focusable);\n            (0, $j4Qbl$scrollIntoViewport)(focusable, {\n              containingElement: (0, $j4Qbl$getScrollParent)(ref.current)\n            });\n          } else {\n            // If there is no next focusable child, then move to the next cell to the left of this one.\n            // This will be handled by useSelectableCollection. However, if there is no cell to the left\n            // of this one, only one column, and the grid doesn't focus rows, then the next key will be the\n            // same as this one. In that case we need to handle focusing either the cell or the first/last\n            // child, depending on the focus mode.\n            let prev = keyboardDelegate.getKeyLeftOf(node.key);\n            if (prev !== node.key) {\n              // We prevent the capturing event from reaching children of the cell, e.g. pickers.\n              // We want arrow keys to navigate to the next cell instead. We need to re-dispatch \n              // the event from a higher parent so it still bubbles and gets handled by useSelectableCollection.\n              ref.current.parentElement.dispatchEvent(new KeyboardEvent(e.nativeEvent.type, e.nativeEvent));\n              break;\n            }\n            if (focusMode === 'cell' && direction === 'rtl') {\n              (0, $j4Qbl$focusSafely)(ref.current);\n              (0, $j4Qbl$scrollIntoViewport)(ref.current, {\n                containingElement: (0, $j4Qbl$getScrollParent)(ref.current)\n              });\n            } else {\n              walker.currentNode = ref.current;\n              focusable = direction === 'rtl' ? walker.firstChild() : $ab90dcbc1b5466d0$var$last(walker);\n              if (focusable) {\n                (0, $j4Qbl$focusSafely)(focusable);\n                (0, $j4Qbl$scrollIntoViewport)(focusable, {\n                  containingElement: (0, $j4Qbl$getScrollParent)(ref.current)\n                });\n              }\n            }\n          }\n          break;\n        }\n      case 'ArrowRight':\n        {\n          let focusable = direction === 'rtl' ? walker.previousNode() : walker.nextNode();\n          if (focusMode === 'child' && focusable === ref.current) focusable = null;\n          e.preventDefault();\n          e.stopPropagation();\n          if (focusable) {\n            (0, $j4Qbl$focusSafely)(focusable);\n            (0, $j4Qbl$scrollIntoViewport)(focusable, {\n              containingElement: (0, $j4Qbl$getScrollParent)(ref.current)\n            });\n          } else {\n            let next = keyboardDelegate.getKeyRightOf(node.key);\n            if (next !== node.key) {\n              // We prevent the capturing event from reaching children of the cell, e.g. pickers.\n              // We want arrow keys to navigate to the next cell instead. We need to re-dispatch \n              // the event from a higher parent so it still bubbles and gets handled by useSelectableCollection.\n              ref.current.parentElement.dispatchEvent(new KeyboardEvent(e.nativeEvent.type, e.nativeEvent));\n              break;\n            }\n            if (focusMode === 'cell' && direction === 'ltr') {\n              (0, $j4Qbl$focusSafely)(ref.current);\n              (0, $j4Qbl$scrollIntoViewport)(ref.current, {\n                containingElement: (0, $j4Qbl$getScrollParent)(ref.current)\n              });\n            } else {\n              walker.currentNode = ref.current;\n              focusable = direction === 'rtl' ? $ab90dcbc1b5466d0$var$last(walker) : walker.firstChild();\n              if (focusable) {\n                (0, $j4Qbl$focusSafely)(focusable);\n                (0, $j4Qbl$scrollIntoViewport)(focusable, {\n                  containingElement: (0, $j4Qbl$getScrollParent)(ref.current)\n                });\n              }\n            }\n          }\n          break;\n        }\n      case 'ArrowUp':\n      case 'ArrowDown':\n        // Prevent this event from reaching cell children, e.g. menu buttons. We want arrow keys to navigate\n        // to the cell above/below instead. We need to re-dispatch the event from a higher parent so it still\n        // bubbles and gets handled by useSelectableCollection.\n        if (!e.altKey && ref.current.contains(e.target)) {\n          e.stopPropagation();\n          e.preventDefault();\n          ref.current.parentElement.dispatchEvent(new KeyboardEvent(e.nativeEvent.type, e.nativeEvent));\n        }\n        break;\n    }\n  };\n  // Grid cells can have focusable elements inside them. In this case, focus should\n  // be marshalled to that element rather than focusing the cell itself.\n  let onFocus = e => {\n    keyWhenFocused.current = node.key;\n    if (e.target !== ref.current) {\n      // useSelectableItem only handles setting the focused key when\n      // the focused element is the gridcell itself. We also want to\n      // set the focused key when a child element receives focus.\n      // If focus is currently visible (e.g. the user is navigating with the keyboard),\n      // then skip this. We want to restore focus to the previously focused row/cell\n      // in that case since the table should act like a single tab stop.\n      if (!(0, $j4Qbl$isFocusVisible)()) state.selectionManager.setFocusedKey(node.key);\n      return;\n    }\n    // If the cell itself is focused, wait a frame so that focus finishes propagatating\n    // up to the tree, and move focus to a focusable child if possible.\n    requestAnimationFrame(() => {\n      if (focusMode === 'child' && document.activeElement === ref.current) focus();\n    });\n  };\n  let gridCellProps = (0, $j4Qbl$mergeProps)(itemProps, {\n    role: 'gridcell',\n    onKeyDownCapture: onKeyDownCapture,\n    onFocus: onFocus\n  });\n  var _node_colIndex;\n  if (isVirtualized) gridCellProps['aria-colindex'] = ((_node_colIndex = node.colIndex) !== null && _node_colIndex !== void 0 ? _node_colIndex : node.index) + 1; // aria-colindex is 1-based\n  // When pressing with a pointer and cell selection is not enabled, usePress will be applied to the\n  // row rather than the cell. However, when the row is draggable, usePress cannot preventDefault\n  // on pointer down, so the browser will try to focus the cell which has a tabIndex applied.\n  // To avoid this, remove the tabIndex from the cell briefly on pointer down.\n  if (shouldSelectOnPressUp && gridCellProps.tabIndex != null && gridCellProps.onPointerDown == null) gridCellProps.onPointerDown = e => {\n    let el = e.currentTarget;\n    let tabindex = el.getAttribute('tabindex');\n    el.removeAttribute('tabindex');\n    requestAnimationFrame(() => {\n      el.setAttribute('tabindex', tabindex);\n    });\n  };\n  return {\n    gridCellProps: gridCellProps,\n    isPressed: isPressed\n  };\n}\nfunction $ab90dcbc1b5466d0$var$last(walker) {\n  let next;\n  let last;\n  do {\n    last = walker.lastChild();\n    if (last) next = last;\n  } while (last);\n  return next;\n}\nexport { $ab90dcbc1b5466d0$export$c7e10bfc0c59f67c as useGridCell };","map":{"version":3,"names":["$ab90dcbc1b5466d0$export$c7e10bfc0c59f67c","props","state","ref","node","isVirtualized","focusMode","shouldSelectOnPressUp","onAction","direction","$j4Qbl$useLocale","keyboardDelegate","actions","onCellAction","$1af922eb41e03c8f$export$e6235c0d09b995d0","get","keyWhenFocused","$j4Qbl$useRef","focus","treeWalker","$j4Qbl$getFocusableTreeWalker","current","contains","document","activeElement","focusable","selectionManager","childFocusStrategy","$ab90dcbc1b5466d0$var$last","firstChild","$j4Qbl$focusSafely","key","itemProps","isPressed","$j4Qbl$useSelectableItem","isDisabled","collection","size","onKeyDownCapture","e","currentTarget","target","isKeyboardNavigationDisabled","walker","currentNode","nextNode","previousNode","preventDefault","stopPropagation","$j4Qbl$scrollIntoViewport","containingElement","$j4Qbl$getScrollParent","prev","getKeyLeftOf","parentElement","dispatchEvent","KeyboardEvent","nativeEvent","type","next","getKeyRightOf","altKey","onFocus","$j4Qbl$isFocusVisible","setFocusedKey","requestAnimationFrame","gridCellProps","$j4Qbl$mergeProps","role","_node_colIndex","colIndex","index","tabIndex","onPointerDown","el","tabindex","getAttribute","removeAttribute","setAttribute","last","lastChild"],"sources":["/Users/mario/Documents/Development/portfolio/node_modules/@react-aria/grid/dist/packages/@react-aria/grid/src/useGridCell.ts"],"sourcesContent":["/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nimport {DOMAttributes, FocusableElement} from '@react-types/shared';\nimport {focusSafely, getFocusableTreeWalker} from '@react-aria/focus';\nimport {getScrollParent, mergeProps, scrollIntoViewport} from '@react-aria/utils';\nimport {GridCollection, GridNode} from '@react-types/grid';\nimport {gridMap} from './utils';\nimport {GridState} from '@react-stately/grid';\nimport {isFocusVisible} from '@react-aria/interactions';\nimport {KeyboardEvent as ReactKeyboardEvent, RefObject, useRef} from 'react';\nimport {useLocale} from '@react-aria/i18n';\nimport {useSelectableItem} from '@react-aria/selection';\n\nexport interface GridCellProps {\n  /** An object representing the grid cell. Contains all the relevant information that makes up the grid cell. */\n  node: GridNode<unknown>,\n  /** Whether the grid cell is contained in a virtual scroller. */\n  isVirtualized?: boolean,\n  /** Whether the cell or its first focusable child element should be focused when the grid cell is focused. */\n  focusMode?: 'child' | 'cell',\n  /** Whether selection should occur on press up instead of press down. */\n  shouldSelectOnPressUp?: boolean,\n  /**\n   * Handler that is called when a user performs an action on the cell.\n   * Please use onCellAction at the collection level instead.\n   * @deprecated\n   **/\n  onAction?: () => void\n}\n\nexport interface GridCellAria {\n  /** Props for the grid cell element. */\n  gridCellProps: DOMAttributes,\n  /** Whether the cell is currently in a pressed state. */\n  isPressed: boolean\n}\n\n/**\n * Provides the behavior and accessibility implementation for a cell in a grid.\n * @param props - Props for the cell.\n * @param state - State of the parent grid, as returned by `useGridState`.\n */\nexport function useGridCell<T, C extends GridCollection<T>>(props: GridCellProps, state: GridState<T, C>, ref: RefObject<FocusableElement>): GridCellAria {\n  let {\n    node,\n    isVirtualized,\n    focusMode = 'child',\n    shouldSelectOnPressUp,\n    onAction\n  } = props;\n\n  let {direction} = useLocale();\n  let {keyboardDelegate, actions: {onCellAction}} = gridMap.get(state);\n\n  // We need to track the key of the item at the time it was last focused so that we force\n  // focus to go to the item when the DOM node is reused for a different item in a virtualizer.\n  let keyWhenFocused = useRef(null);\n\n  // Handles focusing the cell. If there is a focusable child,\n  // it is focused, otherwise the cell itself is focused.\n  let focus = () => {\n    let treeWalker = getFocusableTreeWalker(ref.current);\n    if (focusMode === 'child') {\n      // If focus is already on a focusable child within the cell, early return so we don't shift focus\n      if (ref.current.contains(document.activeElement) && ref.current !== document.activeElement) {\n        return;\n      }\n\n      let focusable = state.selectionManager.childFocusStrategy === 'last'\n        ? last(treeWalker)\n        : treeWalker.firstChild() as FocusableElement;\n      if (focusable) {\n        focusSafely(focusable);\n        return;\n      }\n    }\n\n    if (\n      (keyWhenFocused.current != null && node.key !== keyWhenFocused.current) ||\n      !ref.current.contains(document.activeElement)\n    ) {\n      focusSafely(ref.current);\n    }\n  };\n\n  let {itemProps, isPressed} = useSelectableItem({\n    selectionManager: state.selectionManager,\n    key: node.key,\n    ref,\n    isVirtualized,\n    focus,\n    shouldSelectOnPressUp,\n    onAction: onCellAction ? () => onCellAction(node.key) : onAction,\n    isDisabled: state.collection.size === 0\n  });\n\n  let onKeyDownCapture = (e: ReactKeyboardEvent) => {\n    if (!e.currentTarget.contains(e.target as Element) || state.isKeyboardNavigationDisabled) {\n      return;\n    }\n\n    let walker = getFocusableTreeWalker(ref.current);\n    walker.currentNode = document.activeElement;\n\n    switch (e.key) {\n      case 'ArrowLeft': {\n        // Find the next focusable element within the cell.\n        let focusable = direction === 'rtl'\n          ? walker.nextNode() as FocusableElement\n          : walker.previousNode() as FocusableElement;\n\n        // Don't focus the cell itself if focusMode is \"child\"\n        if (focusMode === 'child' && focusable === ref.current) {\n          focusable = null;\n        }\n\n        e.preventDefault();\n        e.stopPropagation();\n        if (focusable) {\n          focusSafely(focusable);\n          scrollIntoViewport(focusable, {containingElement: getScrollParent(ref.current)});\n        } else {\n          // If there is no next focusable child, then move to the next cell to the left of this one.\n          // This will be handled by useSelectableCollection. However, if there is no cell to the left\n          // of this one, only one column, and the grid doesn't focus rows, then the next key will be the\n          // same as this one. In that case we need to handle focusing either the cell or the first/last\n          // child, depending on the focus mode.\n          let prev = keyboardDelegate.getKeyLeftOf(node.key);\n          if (prev !== node.key) {\n            // We prevent the capturing event from reaching children of the cell, e.g. pickers.\n            // We want arrow keys to navigate to the next cell instead. We need to re-dispatch \n            // the event from a higher parent so it still bubbles and gets handled by useSelectableCollection.\n            ref.current.parentElement.dispatchEvent(\n              new KeyboardEvent(e.nativeEvent.type, e.nativeEvent)\n            );\n            break;\n          }\n\n          if (focusMode === 'cell' && direction === 'rtl') {\n            focusSafely(ref.current);\n            scrollIntoViewport(ref.current, {containingElement: getScrollParent(ref.current)});\n          } else {\n            walker.currentNode = ref.current;\n            focusable = direction === 'rtl'\n              ? walker.firstChild() as FocusableElement\n              : last(walker);\n            if (focusable) {\n              focusSafely(focusable);\n              scrollIntoViewport(focusable, {containingElement: getScrollParent(ref.current)});\n            }\n          }\n        }\n        break;\n      }\n      case 'ArrowRight': {\n        let focusable = direction === 'rtl'\n          ? walker.previousNode() as FocusableElement\n          : walker.nextNode() as FocusableElement;\n\n        if (focusMode === 'child' && focusable === ref.current) {\n          focusable = null;\n        }\n\n        e.preventDefault();\n        e.stopPropagation();\n        if (focusable) {\n          focusSafely(focusable);\n          scrollIntoViewport(focusable, {containingElement: getScrollParent(ref.current)});\n        } else {\n          let next = keyboardDelegate.getKeyRightOf(node.key);\n          if (next !== node.key) {\n            // We prevent the capturing event from reaching children of the cell, e.g. pickers.\n            // We want arrow keys to navigate to the next cell instead. We need to re-dispatch \n            // the event from a higher parent so it still bubbles and gets handled by useSelectableCollection.\n            ref.current.parentElement.dispatchEvent(\n              new KeyboardEvent(e.nativeEvent.type, e.nativeEvent)\n            );\n            break;\n          }\n\n          if (focusMode === 'cell' && direction === 'ltr') {\n            focusSafely(ref.current);\n            scrollIntoViewport(ref.current, {containingElement: getScrollParent(ref.current)});\n          } else {\n            walker.currentNode = ref.current;\n            focusable = direction === 'rtl'\n              ? last(walker)\n              : walker.firstChild() as FocusableElement;\n            if (focusable) {\n              focusSafely(focusable);\n              scrollIntoViewport(focusable, {containingElement: getScrollParent(ref.current)});\n            }\n          }\n        }\n        break;\n      }\n      case 'ArrowUp':\n      case 'ArrowDown':\n        // Prevent this event from reaching cell children, e.g. menu buttons. We want arrow keys to navigate\n        // to the cell above/below instead. We need to re-dispatch the event from a higher parent so it still\n        // bubbles and gets handled by useSelectableCollection.\n        if (!e.altKey && ref.current.contains(e.target as Element)) {\n          e.stopPropagation();\n          e.preventDefault();\n          ref.current.parentElement.dispatchEvent(\n            new KeyboardEvent(e.nativeEvent.type, e.nativeEvent)\n          );\n        }\n        break;\n    }\n  };\n\n  // Grid cells can have focusable elements inside them. In this case, focus should\n  // be marshalled to that element rather than focusing the cell itself.\n  let onFocus = (e) => {\n    keyWhenFocused.current = node.key;\n    if (e.target !== ref.current) {\n      // useSelectableItem only handles setting the focused key when\n      // the focused element is the gridcell itself. We also want to\n      // set the focused key when a child element receives focus.\n      // If focus is currently visible (e.g. the user is navigating with the keyboard),\n      // then skip this. We want to restore focus to the previously focused row/cell\n      // in that case since the table should act like a single tab stop.\n      if (!isFocusVisible()) {\n        state.selectionManager.setFocusedKey(node.key);\n      }\n      return;\n    }\n\n    // If the cell itself is focused, wait a frame so that focus finishes propagatating\n    // up to the tree, and move focus to a focusable child if possible.\n    requestAnimationFrame(() => {\n      if (focusMode === 'child' && document.activeElement === ref.current) {\n        focus();\n      }\n    });\n  };\n\n  let gridCellProps: DOMAttributes = mergeProps(itemProps, {\n    role: 'gridcell',\n    onKeyDownCapture,\n    onFocus\n  });\n\n  if (isVirtualized) {\n    gridCellProps['aria-colindex'] = (node.colIndex ?? node.index) + 1; // aria-colindex is 1-based\n  }\n\n  // When pressing with a pointer and cell selection is not enabled, usePress will be applied to the\n  // row rather than the cell. However, when the row is draggable, usePress cannot preventDefault\n  // on pointer down, so the browser will try to focus the cell which has a tabIndex applied.\n  // To avoid this, remove the tabIndex from the cell briefly on pointer down.\n  if (shouldSelectOnPressUp && gridCellProps.tabIndex != null && gridCellProps.onPointerDown == null) {\n    gridCellProps.onPointerDown = (e) => {\n      let el = e.currentTarget;\n      let tabindex = el.getAttribute('tabindex');\n      el.removeAttribute('tabindex');\n      requestAnimationFrame(() => {\n        el.setAttribute('tabindex', tabindex);\n      });\n    };\n  }\n\n  return {\n    gridCellProps,\n    isPressed\n  };\n}\n\nfunction last(walker: TreeWalker) {\n  let next: FocusableElement;\n  let last: FocusableElement;\n  do {\n    last = walker.lastChild() as FocusableElement;\n    if (last) {\n      next = last;\n    }\n  } while (last);\n  return next;\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}