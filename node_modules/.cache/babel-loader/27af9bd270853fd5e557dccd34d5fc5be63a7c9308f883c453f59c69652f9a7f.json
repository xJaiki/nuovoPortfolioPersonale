{"ast":null,"code":"import { getEraFormat as $a074e1e2d0f0a665$export$134cbb7fb09a9522, hookData as $a074e1e2d0f0a665$export$653eddfc964b0f8a } from \"./utils.mjs\";\nimport $dm6hl$intlStringsmodulejs from \"./intlStrings.mjs\";\nimport { isSameDay as $dm6hl$isSameDay, isEqualDay as $dm6hl$isEqualDay, isToday as $dm6hl$isToday } from \"@internationalized/date\";\nimport { useDeepMemo as $dm6hl$useDeepMemo, useDescription as $dm6hl$useDescription, focusWithoutScrolling as $dm6hl$focusWithoutScrolling, scrollIntoViewport as $dm6hl$scrollIntoViewport, getScrollParent as $dm6hl$getScrollParent, mergeProps as $dm6hl$mergeProps } from \"@react-aria/utils\";\nimport { usePress as $dm6hl$usePress, getInteractionModality as $dm6hl$getInteractionModality } from \"@react-aria/interactions\";\nimport { useMemo as $dm6hl$useMemo, useRef as $dm6hl$useRef, useEffect as $dm6hl$useEffect } from \"react\";\nimport { useLocalizedStringFormatter as $dm6hl$useLocalizedStringFormatter, useDateFormatter as $dm6hl$useDateFormatter } from \"@react-aria/i18n\";\nfunction $parcel$interopDefault(a) {\n  return a && a.__esModule ? a.default : a;\n}\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nfunction $36a0ac60f04457c5$export$136073280381448e(props, state, ref) {\n  let {\n    date: date,\n    isDisabled: isDisabled\n  } = props;\n  let {\n    errorMessageId: errorMessageId,\n    selectedDateDescription: selectedDateDescription\n  } = (0, $a074e1e2d0f0a665$export$653eddfc964b0f8a).get(state);\n  let stringFormatter = (0, $dm6hl$useLocalizedStringFormatter)((0, $parcel$interopDefault($dm6hl$intlStringsmodulejs)), '@react-aria/calendar');\n  let dateFormatter = (0, $dm6hl$useDateFormatter)({\n    weekday: 'long',\n    day: 'numeric',\n    month: 'long',\n    year: 'numeric',\n    era: (0, $a074e1e2d0f0a665$export$134cbb7fb09a9522)(date),\n    timeZone: state.timeZone\n  });\n  let isSelected = state.isSelected(date);\n  let isFocused = state.isCellFocused(date);\n  isDisabled = isDisabled || state.isCellDisabled(date);\n  let isUnavailable = state.isCellUnavailable(date);\n  let isSelectable = !isDisabled && !isUnavailable;\n  let isInvalid = state.isValueInvalid && ('highlightedRange' in state ? !state.anchorDate && state.highlightedRange && date.compare(state.highlightedRange.start) >= 0 && date.compare(state.highlightedRange.end) <= 0 : state.value && (0, $dm6hl$isSameDay)(state.value, date));\n  if (isInvalid) isSelected = true;\n  // For performance, reuse the same date object as before if the new date prop is the same.\n  // This allows subsequent useMemo results to be reused.\n  date = (0, $dm6hl$useDeepMemo)(date, (0, $dm6hl$isEqualDay));\n  let nativeDate = (0, $dm6hl$useMemo)(() => date.toDate(state.timeZone), [date, state.timeZone]);\n  // aria-label should be localize Day of week, Month, Day and Year without Time.\n  let isDateToday = (0, $dm6hl$isToday)(date, state.timeZone);\n  let label = (0, $dm6hl$useMemo)(() => {\n    let label = '';\n    // If this is a range calendar, add a description of the full selected range\n    // to the first and last selected date.\n    if ('highlightedRange' in state && state.value && !state.anchorDate && ((0, $dm6hl$isSameDay)(date, state.value.start) || (0, $dm6hl$isSameDay)(date, state.value.end))) label = selectedDateDescription + ', ';\n    label += dateFormatter.format(nativeDate);\n    if (isDateToday)\n      // If date is today, set appropriate string depending on selected state:\n      label = stringFormatter.format(isSelected ? 'todayDateSelected' : 'todayDate', {\n        date: label\n      });else if (isSelected)\n      // If date is selected but not today:\n      label = stringFormatter.format('dateSelected', {\n        date: label\n      });\n    if (state.minValue && (0, $dm6hl$isSameDay)(date, state.minValue)) label += ', ' + stringFormatter.format('minimumDate');else if (state.maxValue && (0, $dm6hl$isSameDay)(date, state.maxValue)) label += ', ' + stringFormatter.format('maximumDate');\n    return label;\n  }, [dateFormatter, nativeDate, stringFormatter, isSelected, isDateToday, date, state, selectedDateDescription]);\n  // When a cell is focused and this is a range calendar, add a prompt to help\n  // screenreader users know that they are in a range selection mode.\n  let rangeSelectionPrompt = '';\n  if ('anchorDate' in state && isFocused && !state.isReadOnly && isSelectable) {\n    // If selection has started add \"click to finish selecting range\"\n    if (state.anchorDate) rangeSelectionPrompt = stringFormatter.format('finishRangeSelectionPrompt');else rangeSelectionPrompt = stringFormatter.format('startRangeSelectionPrompt');\n  }\n  let descriptionProps = (0, $dm6hl$useDescription)(rangeSelectionPrompt);\n  let isAnchorPressed = (0, $dm6hl$useRef)(false);\n  let isRangeBoundaryPressed = (0, $dm6hl$useRef)(false);\n  let touchDragTimerRef = (0, $dm6hl$useRef)(null);\n  let {\n    pressProps: pressProps,\n    isPressed: isPressed\n  } = (0, $dm6hl$usePress)({\n    // When dragging to select a range, we don't want dragging over the original anchor\n    // again to trigger onPressStart. Cancel presses immediately when the pointer exits.\n    shouldCancelOnPointerExit: 'anchorDate' in state && !!state.anchorDate,\n    preventFocusOnPress: true,\n    isDisabled: !isSelectable || state.isReadOnly,\n    onPressStart(e) {\n      if (state.isReadOnly) {\n        state.setFocusedDate(date);\n        return;\n      }\n      if ('highlightedRange' in state && !state.anchorDate && (e.pointerType === 'mouse' || e.pointerType === 'touch')) {\n        // Allow dragging the start or end date of a range to modify it\n        // rather than starting a new selection.\n        // Don't allow dragging when invalid, or weird jumping behavior may occur as date ranges\n        // are constrained to available dates. The user will need to select a new range in this case.\n        if (state.highlightedRange && !isInvalid) {\n          if ((0, $dm6hl$isSameDay)(date, state.highlightedRange.start)) {\n            state.setAnchorDate(state.highlightedRange.end);\n            state.setFocusedDate(date);\n            state.setDragging(true);\n            isRangeBoundaryPressed.current = true;\n            return;\n          } else if ((0, $dm6hl$isSameDay)(date, state.highlightedRange.end)) {\n            state.setAnchorDate(state.highlightedRange.start);\n            state.setFocusedDate(date);\n            state.setDragging(true);\n            isRangeBoundaryPressed.current = true;\n            return;\n          }\n        }\n        let startDragging = () => {\n          state.setDragging(true);\n          touchDragTimerRef.current = null;\n          state.selectDate(date);\n          state.setFocusedDate(date);\n          isAnchorPressed.current = true;\n        };\n        // Start selection on mouse/touch down so users can drag to select a range.\n        // On touch, delay dragging to determine if the user really meant to scroll.\n        if (e.pointerType === 'touch') touchDragTimerRef.current = setTimeout(startDragging, 200);else startDragging();\n      }\n    },\n    onPressEnd() {\n      isRangeBoundaryPressed.current = false;\n      isAnchorPressed.current = false;\n      clearTimeout(touchDragTimerRef.current);\n      touchDragTimerRef.current = null;\n    },\n    onPress() {\n      // For non-range selection, always select on press up.\n      if (!('anchorDate' in state) && !state.isReadOnly) {\n        state.selectDate(date);\n        state.setFocusedDate(date);\n      }\n    },\n    onPressUp(e) {\n      if (state.isReadOnly) return;\n      // If the user tapped quickly, the date won't be selected yet and the\n      // timer will still be in progress. In this case, select the date on touch up.\n      // Timer is cleared in onPressEnd.\n      if ('anchorDate' in state && touchDragTimerRef.current) {\n        state.selectDate(date);\n        state.setFocusedDate(date);\n      }\n      if ('anchorDate' in state) {\n        if (isRangeBoundaryPressed.current)\n          // When clicking on the start or end date of an already selected range,\n          // start a new selection on press up to also allow dragging the date to\n          // change the existing range.\n          state.setAnchorDate(date);else if (state.anchorDate && !isAnchorPressed.current) {\n          // When releasing a drag or pressing the end date of a range, select it.\n          state.selectDate(date);\n          state.setFocusedDate(date);\n        } else if (e.pointerType === 'keyboard' && !state.anchorDate) {\n          // For range selection, auto-advance the focused date by one if using keyboard.\n          // This gives an indication that you're selecting a range rather than a single date.\n          // For mouse, this is unnecessary because users will see the indication on hover. For screen readers,\n          // there will be an announcement to \"click to finish selecting range\" (above).\n          state.selectDate(date);\n          let nextDay = date.add({\n            days: 1\n          });\n          if (state.isInvalid(nextDay)) nextDay = date.subtract({\n            days: 1\n          });\n          if (!state.isInvalid(nextDay)) state.setFocusedDate(nextDay);\n        } else if (e.pointerType === 'virtual') {\n          // For screen readers, just select the date on click.\n          state.selectDate(date);\n          state.setFocusedDate(date);\n        }\n      }\n    }\n  });\n  let tabIndex = null;\n  if (!isDisabled) tabIndex = (0, $dm6hl$isSameDay)(date, state.focusedDate) ? 0 : -1;\n  // Focus the button in the DOM when the state updates.\n  (0, $dm6hl$useEffect)(() => {\n    if (isFocused && ref.current) {\n      (0, $dm6hl$focusWithoutScrolling)(ref.current);\n      // Scroll into view if navigating with a keyboard, otherwise\n      // try not to shift the view under the user's mouse/finger.\n      // If in a overlay, scrollIntoViewport will only cause scrolling\n      // up to the overlay scroll body to prevent overlay shifting.\n      // Also only scroll into view if the cell actually got focused.\n      // There are some cases where the cell might be disabled or inside,\n      // an inert container and we don't want to scroll then.\n      if ((0, $dm6hl$getInteractionModality)() !== 'pointer' && document.activeElement === ref.current) (0, $dm6hl$scrollIntoViewport)(ref.current, {\n        containingElement: (0, $dm6hl$getScrollParent)(ref.current)\n      });\n    }\n  }, [isFocused, ref]);\n  let cellDateFormatter = (0, $dm6hl$useDateFormatter)({\n    day: 'numeric',\n    timeZone: state.timeZone,\n    calendar: date.calendar.identifier\n  });\n  let formattedDate = (0, $dm6hl$useMemo)(() => cellDateFormatter.formatToParts(nativeDate).find(part => part.type === 'day').value, [cellDateFormatter, nativeDate]);\n  return {\n    cellProps: {\n      role: 'gridcell',\n      'aria-disabled': !isSelectable || null,\n      'aria-selected': isSelected || null,\n      'aria-invalid': isInvalid || null\n    },\n    buttonProps: (0, $dm6hl$mergeProps)(pressProps, {\n      onFocus() {\n        if (!isDisabled) state.setFocusedDate(date);\n      },\n      tabIndex: tabIndex,\n      role: 'button',\n      'aria-disabled': !isSelectable || null,\n      'aria-label': label,\n      'aria-invalid': isInvalid || null,\n      'aria-describedby': [isInvalid ? errorMessageId : null, descriptionProps['aria-describedby']].filter(Boolean).join(' ') || undefined,\n      onPointerEnter(e) {\n        // Highlight the date on hover or drag over a date when selecting a range.\n        if ('highlightDate' in state && (e.pointerType !== 'touch' || state.isDragging) && isSelectable) state.highlightDate(date);\n      },\n      onPointerDown(e) {\n        // This is necessary on touch devices to allow dragging\n        // outside the original pressed element.\n        // (JSDOM does not support this)\n        if ('releasePointerCapture' in e.target) e.target.releasePointerCapture(e.pointerId);\n      },\n      onContextMenu(e) {\n        // Prevent context menu on long press.\n        e.preventDefault();\n      }\n    }),\n    isPressed: isPressed,\n    isFocused: isFocused,\n    isSelected: isSelected,\n    isDisabled: isDisabled,\n    isUnavailable: isUnavailable,\n    isOutsideVisibleRange: date.compare(state.visibleRange.start) < 0 || date.compare(state.visibleRange.end) > 0,\n    isInvalid: isInvalid,\n    formattedDate: formattedDate\n  };\n}\nexport { $36a0ac60f04457c5$export$136073280381448e as useCalendarCell };","map":{"version":3,"names":["$36a0ac60f04457c5$export$136073280381448e","props","state","ref","date","isDisabled","errorMessageId","selectedDateDescription","$a074e1e2d0f0a665$export$653eddfc964b0f8a","get","stringFormatter","$dm6hl$useLocalizedStringFormatter","$parcel$interopDefault","$dm6hl$intlStringsmodulejs","dateFormatter","$dm6hl$useDateFormatter","weekday","day","month","year","era","$a074e1e2d0f0a665$export$134cbb7fb09a9522","timeZone","isSelected","isFocused","isCellFocused","isCellDisabled","isUnavailable","isCellUnavailable","isSelectable","isInvalid","isValueInvalid","anchorDate","highlightedRange","compare","start","end","value","$dm6hl$isSameDay","$dm6hl$useDeepMemo","$dm6hl$isEqualDay","nativeDate","$dm6hl$useMemo","toDate","isDateToday","$dm6hl$isToday","label","format","minValue","maxValue","rangeSelectionPrompt","isReadOnly","descriptionProps","$dm6hl$useDescription","isAnchorPressed","$dm6hl$useRef","isRangeBoundaryPressed","touchDragTimerRef","pressProps","isPressed","$dm6hl$usePress","shouldCancelOnPointerExit","preventFocusOnPress","onPressStart","e","setFocusedDate","pointerType","setAnchorDate","setDragging","current","startDragging","selectDate","setTimeout","onPressEnd","clearTimeout","onPress","onPressUp","nextDay","add","days","subtract","tabIndex","focusedDate","$dm6hl$useEffect","$dm6hl$focusWithoutScrolling","$dm6hl$getInteractionModality","document","activeElement","$dm6hl$scrollIntoViewport","containingElement","$dm6hl$getScrollParent","cellDateFormatter","calendar","identifier","formattedDate","formatToParts","find","part","type","cellProps","role","buttonProps","$dm6hl$mergeProps","onFocus","filter","Boolean","join","undefined","onPointerEnter","isDragging","highlightDate","onPointerDown","target","releasePointerCapture","pointerId","onContextMenu","preventDefault","isOutsideVisibleRange","visibleRange"],"sources":["/Users/mario/Documents/Development/portfolio/node_modules/@react-aria/calendar/dist/packages/@react-aria/calendar/src/useCalendarCell.ts"],"sourcesContent":["/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nimport {CalendarDate, isEqualDay, isSameDay, isToday} from '@internationalized/date';\nimport {CalendarState, RangeCalendarState} from '@react-stately/calendar';\nimport {DOMAttributes} from '@react-types/shared';\nimport {focusWithoutScrolling, getScrollParent, mergeProps, scrollIntoViewport, useDeepMemo, useDescription} from '@react-aria/utils';\nimport {getEraFormat, hookData} from './utils';\nimport {getInteractionModality, usePress} from '@react-aria/interactions';\n// @ts-ignore\nimport intlMessages from '../intl/*.json';\nimport {RefObject, useEffect, useMemo, useRef} from 'react';\nimport {useDateFormatter, useLocalizedStringFormatter} from '@react-aria/i18n';\n\nexport interface AriaCalendarCellProps {\n  /** The date that this cell represents. */\n  date: CalendarDate,\n  /**\n   * Whether the cell is disabled. By default, this is determined by the\n   * Calendar's `minValue`, `maxValue`, and `isDisabled` props.\n   */\n  isDisabled?: boolean\n}\n\nexport interface CalendarCellAria {\n  /** Props for the grid cell element (e.g. `<td>`). */\n  cellProps: DOMAttributes,\n  /** Props for the button element within the cell. */\n  buttonProps: DOMAttributes,\n  /** Whether the cell is currently being pressed. */\n  isPressed: boolean,\n  /** Whether the cell is selected. */\n  isSelected: boolean,\n  /** Whether the cell is focused. */\n  isFocused: boolean,\n  /**\n   * Whether the cell is disabled, according to the calendar's `minValue`, `maxValue`, and `isDisabled` props.\n   * Disabled dates are not focusable, and cannot be selected by the user. They are typically\n   * displayed with a dimmed appearance.\n   */\n  isDisabled: boolean,\n  /**\n   * Whether the cell is unavailable, according to the calendar's `isDateUnavailable` prop. Unavailable dates remain\n   * focusable, but cannot be selected by the user. They should be displayed with a visual affordance to indicate they\n   * are unavailable, such as a different color or a strikethrough.\n   *\n   * Note that because they are focusable, unavailable dates must meet a 4.5:1 color contrast ratio,\n   * [as defined by WCAG](https://www.w3.org/WAI/WCAG21/Understanding/contrast-minimum.html).\n   */\n  isUnavailable: boolean,\n  /**\n   * Whether the cell is outside the visible range of the calendar.\n   * For example, dates before the first day of a month in the same week.\n   */\n  isOutsideVisibleRange: boolean,\n  /** Whether the cell is part of an invalid selection. */\n  isInvalid: boolean,\n  /** The day number formatted according to the current locale. */\n  formattedDate: string\n}\n\n/**\n * Provides the behavior and accessibility implementation for a calendar cell component.\n * A calendar cell displays a date cell within a calendar grid which can be selected by the user.\n */\nexport function useCalendarCell(props: AriaCalendarCellProps, state: CalendarState | RangeCalendarState, ref: RefObject<HTMLElement>): CalendarCellAria {\n  let {date, isDisabled} = props;\n  let {errorMessageId, selectedDateDescription} = hookData.get(state);\n  let stringFormatter = useLocalizedStringFormatter(intlMessages, '@react-aria/calendar');\n  let dateFormatter = useDateFormatter({\n    weekday: 'long',\n    day: 'numeric',\n    month: 'long',\n    year: 'numeric',\n    era: getEraFormat(date),\n    timeZone: state.timeZone\n  });\n  let isSelected = state.isSelected(date);\n  let isFocused = state.isCellFocused(date);\n  isDisabled = isDisabled || state.isCellDisabled(date);\n  let isUnavailable = state.isCellUnavailable(date);\n  let isSelectable = !isDisabled && !isUnavailable;\n  let isInvalid = state.isValueInvalid && (\n    'highlightedRange' in state\n      ? !state.anchorDate && state.highlightedRange && date.compare(state.highlightedRange.start) >= 0 && date.compare(state.highlightedRange.end) <= 0\n      : state.value && isSameDay(state.value, date)\n  );\n\n  if (isInvalid) {\n    isSelected = true;\n  }\n\n  // For performance, reuse the same date object as before if the new date prop is the same.\n  // This allows subsequent useMemo results to be reused.\n  date = useDeepMemo<CalendarDate>(date, isEqualDay);\n  let nativeDate = useMemo(() => date.toDate(state.timeZone), [date, state.timeZone]);\n\n  // aria-label should be localize Day of week, Month, Day and Year without Time.\n  let isDateToday = isToday(date, state.timeZone);\n  let label = useMemo(() => {\n    let label = '';\n\n    // If this is a range calendar, add a description of the full selected range\n    // to the first and last selected date.\n    if (\n      'highlightedRange' in state &&\n      state.value &&\n      !state.anchorDate &&\n      (isSameDay(date, state.value.start) || isSameDay(date, state.value.end))\n    ) {\n      label = selectedDateDescription + ', ';\n    }\n\n    label += dateFormatter.format(nativeDate);\n    if (isDateToday) {\n      // If date is today, set appropriate string depending on selected state:\n      label = stringFormatter.format(isSelected ? 'todayDateSelected' : 'todayDate', {\n        date: label\n      });\n    } else if (isSelected) {\n      // If date is selected but not today:\n      label = stringFormatter.format('dateSelected', {\n        date: label\n      });\n    }\n\n    if (state.minValue && isSameDay(date, state.minValue)) {\n      label += ', ' + stringFormatter.format('minimumDate');\n    } else if (state.maxValue && isSameDay(date, state.maxValue)) {\n      label += ', ' + stringFormatter.format('maximumDate');\n    }\n\n    return label;\n  }, [dateFormatter, nativeDate, stringFormatter, isSelected, isDateToday, date, state, selectedDateDescription]);\n\n  // When a cell is focused and this is a range calendar, add a prompt to help\n  // screenreader users know that they are in a range selection mode.\n  let rangeSelectionPrompt = '';\n  if ('anchorDate' in state && isFocused && !state.isReadOnly && isSelectable) {\n    // If selection has started add \"click to finish selecting range\"\n    if (state.anchorDate) {\n      rangeSelectionPrompt = stringFormatter.format('finishRangeSelectionPrompt');\n    // Otherwise, add \"click to start selecting range\" prompt\n    } else {\n      rangeSelectionPrompt = stringFormatter.format('startRangeSelectionPrompt');\n    }\n  }\n\n  let descriptionProps = useDescription(rangeSelectionPrompt);\n\n  let isAnchorPressed = useRef(false);\n  let isRangeBoundaryPressed = useRef(false);\n  let touchDragTimerRef = useRef(null);\n  let {pressProps, isPressed} = usePress({\n    // When dragging to select a range, we don't want dragging over the original anchor\n    // again to trigger onPressStart. Cancel presses immediately when the pointer exits.\n    shouldCancelOnPointerExit: 'anchorDate' in state && !!state.anchorDate,\n    preventFocusOnPress: true,\n    isDisabled: !isSelectable || state.isReadOnly,\n    onPressStart(e) {\n      if (state.isReadOnly) {\n        state.setFocusedDate(date);\n        return;\n      }\n\n      if ('highlightedRange' in state && !state.anchorDate && (e.pointerType === 'mouse' || e.pointerType === 'touch')) {\n        // Allow dragging the start or end date of a range to modify it\n        // rather than starting a new selection.\n        // Don't allow dragging when invalid, or weird jumping behavior may occur as date ranges\n        // are constrained to available dates. The user will need to select a new range in this case.\n        if (state.highlightedRange && !isInvalid) {\n          if (isSameDay(date, state.highlightedRange.start)) {\n            state.setAnchorDate(state.highlightedRange.end);\n            state.setFocusedDate(date);\n            state.setDragging(true);\n            isRangeBoundaryPressed.current = true;\n            return;\n          } else if (isSameDay(date, state.highlightedRange.end)) {\n            state.setAnchorDate(state.highlightedRange.start);\n            state.setFocusedDate(date);\n            state.setDragging(true);\n            isRangeBoundaryPressed.current = true;\n            return;\n          }\n        }\n\n        let startDragging = () => {\n          state.setDragging(true);\n          touchDragTimerRef.current = null;\n\n          state.selectDate(date);\n          state.setFocusedDate(date);\n          isAnchorPressed.current = true;\n        };\n\n        // Start selection on mouse/touch down so users can drag to select a range.\n        // On touch, delay dragging to determine if the user really meant to scroll.\n        if (e.pointerType === 'touch') {\n          touchDragTimerRef.current = setTimeout(startDragging, 200);\n        } else {\n          startDragging();\n        }\n      }\n    },\n    onPressEnd() {\n      isRangeBoundaryPressed.current = false;\n      isAnchorPressed.current = false;\n      clearTimeout(touchDragTimerRef.current);\n      touchDragTimerRef.current = null;\n    },\n    onPress() {\n      // For non-range selection, always select on press up.\n      if (!('anchorDate' in state) && !state.isReadOnly) {\n        state.selectDate(date);\n        state.setFocusedDate(date);\n      }\n    },\n    onPressUp(e) {\n      if (state.isReadOnly) {\n        return;\n      }\n\n      // If the user tapped quickly, the date won't be selected yet and the\n      // timer will still be in progress. In this case, select the date on touch up.\n      // Timer is cleared in onPressEnd.\n      if ('anchorDate' in state && touchDragTimerRef.current) {\n        state.selectDate(date);\n        state.setFocusedDate(date);\n      }\n\n      if ('anchorDate' in state) {\n        if (isRangeBoundaryPressed.current) {\n          // When clicking on the start or end date of an already selected range,\n          // start a new selection on press up to also allow dragging the date to\n          // change the existing range.\n          state.setAnchorDate(date);\n        } else if (state.anchorDate && !isAnchorPressed.current) {\n          // When releasing a drag or pressing the end date of a range, select it.\n          state.selectDate(date);\n          state.setFocusedDate(date);\n        } else if (e.pointerType === 'keyboard' && !state.anchorDate) {\n          // For range selection, auto-advance the focused date by one if using keyboard.\n          // This gives an indication that you're selecting a range rather than a single date.\n          // For mouse, this is unnecessary because users will see the indication on hover. For screen readers,\n          // there will be an announcement to \"click to finish selecting range\" (above).\n          state.selectDate(date);\n          let nextDay = date.add({days: 1});\n          if (state.isInvalid(nextDay)) {\n            nextDay = date.subtract({days: 1});\n          }\n          if (!state.isInvalid(nextDay)) {\n            state.setFocusedDate(nextDay);\n          }\n        } else if (e.pointerType === 'virtual') {\n          // For screen readers, just select the date on click.\n          state.selectDate(date);\n          state.setFocusedDate(date);\n        }\n      }\n    }\n  });\n\n  let tabIndex = null;\n  if (!isDisabled) {\n    tabIndex = isSameDay(date, state.focusedDate) ? 0 : -1;\n  }\n\n  // Focus the button in the DOM when the state updates.\n  useEffect(() => {\n    if (isFocused && ref.current) {\n      focusWithoutScrolling(ref.current);\n\n      // Scroll into view if navigating with a keyboard, otherwise\n      // try not to shift the view under the user's mouse/finger.\n      // If in a overlay, scrollIntoViewport will only cause scrolling\n      // up to the overlay scroll body to prevent overlay shifting.\n      // Also only scroll into view if the cell actually got focused.\n      // There are some cases where the cell might be disabled or inside,\n      // an inert container and we don't want to scroll then.\n      if (getInteractionModality() !== 'pointer' && document.activeElement === ref.current) {\n        scrollIntoViewport(ref.current, {containingElement: getScrollParent(ref.current)});\n      }\n    }\n  }, [isFocused, ref]);\n\n  let cellDateFormatter = useDateFormatter({\n    day: 'numeric',\n    timeZone: state.timeZone,\n    calendar: date.calendar.identifier\n  });\n\n  let formattedDate = useMemo(() => cellDateFormatter.formatToParts(nativeDate).find(part => part.type === 'day').value, [cellDateFormatter, nativeDate]);\n\n  return {\n    cellProps: {\n      role: 'gridcell',\n      'aria-disabled': !isSelectable || null,\n      'aria-selected': isSelected || null,\n      'aria-invalid': isInvalid || null\n    },\n    buttonProps: mergeProps(pressProps, {\n      onFocus() {\n        if (!isDisabled) {\n          state.setFocusedDate(date);\n        }\n      },\n      tabIndex,\n      role: 'button',\n      'aria-disabled': !isSelectable || null,\n      'aria-label': label,\n      'aria-invalid': isInvalid || null,\n      'aria-describedby': [\n        isInvalid ? errorMessageId : null,\n        descriptionProps['aria-describedby']\n      ].filter(Boolean).join(' ') || undefined,\n      onPointerEnter(e) {\n        // Highlight the date on hover or drag over a date when selecting a range.\n        if ('highlightDate' in state && (e.pointerType !== 'touch' || state.isDragging) && isSelectable) {\n          state.highlightDate(date);\n        }\n      },\n      onPointerDown(e) {\n        // This is necessary on touch devices to allow dragging\n        // outside the original pressed element.\n        // (JSDOM does not support this)\n        if ('releasePointerCapture' in e.target) {\n          e.target.releasePointerCapture(e.pointerId);\n        }\n      },\n      onContextMenu(e) {\n        // Prevent context menu on long press.\n        e.preventDefault();\n      }\n    }),\n    isPressed,\n    isFocused,\n    isSelected,\n    isDisabled,\n    isUnavailable,\n    isOutsideVisibleRange: date.compare(state.visibleRange.start) < 0 || date.compare(state.visibleRange.end) > 0,\n    isInvalid,\n    formattedDate\n  };\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}