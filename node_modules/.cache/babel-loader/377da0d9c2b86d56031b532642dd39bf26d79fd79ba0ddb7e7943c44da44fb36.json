{"ast":null,"code":"import { easeOut as $3eb131dcf37ad5f8$export$57636bb43b1ccbb0, tween as $3eb131dcf37ad5f8$export$dc0b63720788090c } from \"./tween.mjs\";\nimport { concatIterators as $fc36f9a046a9ce79$export$cfc14088dfefce5f, difference as $fc36f9a046a9ce79$export$acaf96a27438246b, isSetEqual as $fc36f9a046a9ce79$export$a8d0d0c8d1c5df64 } from \"./utils.mjs\";\nimport { OverscanManager as $364191b3decf3697$export$4455ee6afb38dcbb } from \"./OverscanManager.mjs\";\nimport { Point as $3041db3296945e6e$export$baf26146a414f24a } from \"./Point.mjs\";\nimport { Rect as $60423f92c7f9ad87$export$c79fc6492f3af13d } from \"./Rect.mjs\";\nimport { ReusableView as $ad1d98aa8f0c31b4$export$1a5223887c560441 } from \"./ReusableView.mjs\";\nimport { Size as $ee1bfa90a957fb8a$export$cb6da89c6af1a8ec } from \"./Size.mjs\";\nimport { Transaction as $8e135e531d8dcb66$export$febc5573c75cefb0 } from \"./Transaction.mjs\";\n\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nclass $38b9490c1cca8fc4$export$89be5a243e59c4b2 {\n  _setContentSize(size) {\n    this._contentSize = size;\n    this.delegate.setContentSize(size);\n  }\n  _setContentOffset(offset) {\n    let rect = new (0, $60423f92c7f9ad87$export$c79fc6492f3af13d)(offset.x, offset.y, this._visibleRect.width, this._visibleRect.height);\n    this.delegate.setVisibleRect(rect);\n  }\n  /**\n  * Get the size of the scrollable content.\n  */\n  get contentSize() {\n    return this._contentSize;\n  }\n  /**\n  * Get the collection view's currently visible rectangle.\n  */\n  get visibleRect() {\n    return this._visibleRect;\n  }\n  /**\n  * Set the collection view's currently visible rectangle.\n  */\n  set visibleRect(rect) {\n    this._setVisibleRect(rect);\n  }\n  _setVisibleRect(rect, forceUpdate = false) {\n    let current = this._visibleRect;\n    // Ignore if the rects are equal\n    if (rect.equals(current)) return;\n    if (this.shouldOverscan) this._overscanManager.setVisibleRect(rect);\n    let shouldInvalidate = this.layout && this.layout.shouldInvalidate(rect, this._visibleRect);\n    this._resetAnimatedContentOffset();\n    this._visibleRect = rect;\n    if (shouldInvalidate)\n      // We are already in a layout effect when this method is called, so relayoutNow is appropriate.\n      this.relayoutNow({\n        offsetChanged: !rect.pointEquals(current),\n        sizeChanged: !rect.sizeEquals(current)\n      });else this.updateSubviews(forceUpdate);\n  }\n  get collection() {\n    return this._collection;\n  }\n  set collection(data) {\n    this._setData(data);\n  }\n  _setData(data) {\n    if (data === this._collection) return;\n    if (this._collection) this._runTransaction(() => {\n      this._collection = data;\n    }, this.transitionDuration > 0);else {\n      this._collection = data;\n      this.reloadData();\n    }\n  }\n  /**\n  * Reloads the data from the data source and relayouts the collection view.\n  * Does not animate any changes. Equivalent to re-assigning the same data source\n  * to the collection view.\n  */\n  reloadData() {\n    this.relayout({\n      contentChanged: true\n    });\n  }\n  /**\n  * Returns the item with the given key.\n  */\n  getItem(key) {\n    return this._collection ? this._collection.getItem(key) : null;\n  }\n  /** The set of persisted keys are always present in the DOM, even if not currently in view. */\n  get persistedKeys() {\n    return this._persistedKeys;\n  }\n  /** The set of persisted keys are always present in the DOM, even if not currently in view. */\n  set persistedKeys(persistedKeys) {\n    if (!(0, $fc36f9a046a9ce79$export$a8d0d0c8d1c5df64)(persistedKeys, this._persistedKeys)) {\n      this._persistedKeys = persistedKeys;\n      this.updateSubviews();\n    }\n  }\n  /** Returns whether the given key, or an ancestor, is persisted. */\n  isPersistedKey(key) {\n    // Quick check if the key is directly in the set of persisted keys.\n    if (this._persistedKeys.has(key)) return true;\n    // If not, check if the key is an ancestor of any of the persisted keys.\n    for (let k of this._persistedKeys) while (k != null) {\n      let layoutInfo = this.layout.getLayoutInfo(k);\n      if (!layoutInfo) break;\n      k = layoutInfo.parentKey;\n      if (k === key) return true;\n    }\n    return false;\n  }\n  /**\n  * Get the collection view's layout.\n  */\n  get layout() {\n    return this._layout;\n  }\n  /**\n  * Set the collection view's layout.\n  */\n  set layout(layout) {\n    this.setLayout(layout);\n  }\n  /**\n  * Sets the collection view's layout, optionally with an animated transition\n  * from the current layout to the new layout.\n  * @param layout The layout to switch to.\n  * @param animated Whether to animate the layout change.\n  */\n  setLayout(layout, animated = false) {\n    if (layout === this._layout) return;\n    let applyLayout = () => {\n      if (this._layout)\n        // @ts-ignore\n        this._layout.virtualizer = null;\n      layout.virtualizer = this;\n      this._layout = layout;\n    };\n    if (animated)\n      // Animated layout transitions are really simple, thanks to our transaction support.\n      // We just set the layout inside a transaction action, which runs after the initial\n      // layout infos for the animation are retrieved from the previous layout. Then, the\n      // final layout infos are retrieved from the new layout, and animations occur.\n      this._runTransaction(applyLayout);else {\n      applyLayout();\n      this.relayout();\n    }\n  }\n  _getReuseType(layoutInfo, content) {\n    if (layoutInfo.type === 'item' && content) {\n      let type = this.delegate.getType ? this.delegate.getType(content) : 'item';\n      let reuseType = type === 'item' ? 'item' : layoutInfo.type + '_' + type;\n      return {\n        type: type,\n        reuseType: reuseType\n      };\n    }\n    return {\n      type: layoutInfo.type,\n      reuseType: layoutInfo.type\n    };\n  }\n  getReusableView(layoutInfo) {\n    let content = this.getItem(layoutInfo.key);\n    let {\n      reuseType: reuseType\n    } = this._getReuseType(layoutInfo, content);\n    if (!this._reusableViews[reuseType]) this._reusableViews[reuseType] = [];\n    let reusable = this._reusableViews[reuseType];\n    let view = reusable.length > 0 ? reusable.pop() : new (0, $ad1d98aa8f0c31b4$export$1a5223887c560441)(this);\n    view.viewType = reuseType;\n    if (!this._animatedContentOffset.isOrigin()) {\n      layoutInfo = layoutInfo.copy();\n      layoutInfo.rect.x += this._animatedContentOffset.x;\n      layoutInfo.rect.y += this._animatedContentOffset.y;\n    }\n    view.layoutInfo = layoutInfo;\n    this._renderView(view);\n    return view;\n  }\n  _renderView(reusableView) {\n    let {\n      type: type,\n      key: key\n    } = reusableView.layoutInfo;\n    reusableView.content = this.getItem(key);\n    reusableView.rendered = this._renderContent(type, reusableView.content);\n  }\n  _renderContent(type, content) {\n    let cached = this._renderedContent.get(content);\n    if (cached != null) return cached;\n    let rendered = this.delegate.renderView(type, content);\n    if (content) this._renderedContent.set(content, rendered);\n    return rendered;\n  }\n  /**\n  * Returns an array of all currently visible views, including both\n  * item views and supplementary views.\n  */\n  get visibleViews() {\n    return Array.from(this._visibleViews.values());\n  }\n  /**\n  * Gets the visible view for the given type and key. Returns null if\n  * the view is not currently visible.\n  *\n  * @param key The key of the view to retrieve.\n  */\n  getView(key) {\n    return this._visibleViews.get(key) || null;\n  }\n  /**\n  * Returns an array of visible views matching the given type.\n  * @param type The view type to find.\n  */\n  getViewsOfType(type) {\n    return this.visibleViews.filter(v => v.layoutInfo && v.layoutInfo.type === type);\n  }\n  /**\n  * Returns the key for the given view. Returns null\n  * if the view is not currently visible.\n  */\n  keyForView(view) {\n    if (view && view.layoutInfo) return view.layoutInfo.key;\n    return null;\n  }\n  /**\n  * Returns the key for the item view currently at the given point.\n  */\n  keyAtPoint(point) {\n    let rect = new (0, $60423f92c7f9ad87$export$c79fc6492f3af13d)(point.x, point.y, 1, 1);\n    let layoutInfos = this.layout.getVisibleLayoutInfos(rect);\n    // Layout may return multiple layout infos in the case of\n    // persisted keys, so find the first one that actually intersects.\n    for (let layoutInfo of layoutInfos) {\n      if (layoutInfo.rect.intersects(rect)) return layoutInfo.key;\n    }\n    return null;\n  }\n  /**\n  * Cleanup for when the Virtualizer will be unmounted.\n  */\n  willUnmount() {\n    cancelAnimationFrame(this._relayoutRaf);\n  }\n  /**\n  * Triggers a layout invalidation, and updates the visible subviews.\n  */\n  relayout(context = {}) {\n    // Ignore relayouts while animating the scroll position\n    if (this._scrollAnimation || typeof requestAnimationFrame === 'undefined') return;\n    // If we already scheduled a relayout, extend the invalidation\n    // context so we coalesce multiple relayouts in the same frame.\n    if (this._invalidationContext) {\n      Object.assign(this._invalidationContext, context);\n      return;\n    }\n    this._invalidationContext = context;\n  }\n  /**\n  * Performs a relayout immediately. Prefer {@link relayout} over this method\n  * where possible, since it coalesces multiple layout passes in the same tick.\n  */\n  relayoutNow(context = this._invalidationContext || {}) {\n    // Cancel the scheduled relayout, since we're doing it now.\n    if (this._relayoutRaf) {\n      cancelAnimationFrame(this._relayoutRaf);\n      this._relayoutRaf = null;\n      // Update the provided context with the current invalidationContext since we are cancelling\n      // a scheduled relayoutNow call that has this._invalidationContext set as its default context arg (relayoutNow() in relayout)\n      context = {\n        ...this._invalidationContext,\n        ...context\n      };\n    }\n    // Reset the invalidation context\n    this._invalidationContext = null;\n    // Do nothing if we don't have a layout or content, or we are\n    // in the middle of an animated scroll transition.\n    if (!this.layout || !this._collection || this._scrollAnimation) return;\n    let scrollAnchor = this._getScrollAnchor();\n    // Trigger the beforeLayout hook, if provided\n    if (typeof context.beforeLayout === 'function') context.beforeLayout();\n    // Validate the layout\n    this.layout.validate(context);\n    this._setContentSize(this.layout.getContentSize());\n    // Trigger the afterLayout hook, if provided\n    if (typeof context.afterLayout === 'function') context.afterLayout();\n    // Adjust scroll position based on scroll anchor, and constrain.\n    // If the content changed, scroll to the top.\n    let visibleRect = this.getVisibleRect();\n    let restoredScrollAnchor = this._restoreScrollAnchor(scrollAnchor, context);\n    let contentOffsetX = context.contentChanged ? 0 : restoredScrollAnchor.x;\n    let contentOffsetY = context.contentChanged ? 0 : restoredScrollAnchor.y;\n    contentOffsetX = Math.max(0, Math.min(this.contentSize.width - visibleRect.width, contentOffsetX));\n    contentOffsetY = Math.max(0, Math.min(this.contentSize.height - visibleRect.height, contentOffsetY));\n    let hasLayoutUpdates = false;\n    if (contentOffsetX !== visibleRect.x || contentOffsetY !== visibleRect.y) {\n      // If this is an animated relayout, we do not immediately scroll because it would be jittery.\n      // Save the difference between the current and new content offsets, and apply it to the\n      // individual content items instead. At the end of the animation, we'll reset and set the\n      // scroll offset for real. This ensures jitter-free animation since we don't need to sync\n      // the scroll animation and the content animation.\n      if (context.animated || !this._animatedContentOffset.isOrigin()) {\n        this._animatedContentOffset.x += visibleRect.x - contentOffsetX;\n        this._animatedContentOffset.y += visibleRect.y - contentOffsetY;\n        hasLayoutUpdates = this.updateSubviews(context.contentChanged);\n      } else this._setContentOffset(new (0, $3041db3296945e6e$export$baf26146a414f24a)(contentOffsetX, contentOffsetY));\n    } else hasLayoutUpdates = this.updateSubviews(context.contentChanged);\n    // Apply layout infos, unless this is coming from an animated transaction\n    if (!(context.transaction && context.animated)) this._applyLayoutInfos();\n    // Wait for animations, and apply the afterAnimation hook, if provided\n    if (context.animated && hasLayoutUpdates) {\n      this._enableTransitions();\n      let done = () => {\n        this._disableTransitions();\n        // Reset scroll position after animations (see above comment).\n        if (!this._animatedContentOffset.isOrigin()) {\n          // Get the content offset to scroll to, taking _animatedContentOffset into account.\n          let {\n            x: x,\n            y: y\n          } = this.getVisibleRect();\n          this._resetAnimatedContentOffset();\n          this._setContentOffset(new (0, $3041db3296945e6e$export$baf26146a414f24a)(x, y));\n        }\n        if (typeof context.afterAnimation === 'function') context.afterAnimation();\n      };\n      // Sometimes the animation takes slightly longer than expected.\n      setTimeout(done, this.transitionDuration + 100);\n      return;\n    } else if (typeof context.afterAnimation === 'function') context.afterAnimation();\n  }\n  /**\n  * Corrects DOM order of visible views to match item order of collection.\n  */\n  _correctItemOrder() {\n    // Defer until after scrolling and animated transactions are complete\n    if (this._isScrolling || this._transaction) return;\n    for (let key of this._visibleLayoutInfos.keys()) {\n      let view = this._visibleViews.get(key);\n      this._children.delete(view);\n      this._children.add(view);\n    }\n  }\n  _enableTransitions() {\n    this.delegate.beginAnimations();\n  }\n  _disableTransitions() {\n    this.delegate.endAnimations();\n  }\n  _getScrollAnchor() {\n    if (!this.anchorScrollPosition) return null;\n    let visibleRect = this.getVisibleRect();\n    // Ask the delegate to provide a scroll anchor, if possible\n    if (this.delegate.getScrollAnchor) {\n      let key = this.delegate.getScrollAnchor(visibleRect);\n      if (key != null) {\n        let layoutInfo = this.layout.getLayoutInfo(key);\n        let corner = layoutInfo.rect.getCornerInRect(visibleRect);\n        if (corner) {\n          let key = layoutInfo.key;\n          let offset = layoutInfo.rect[corner].y - visibleRect.y;\n          return {\n            key: key,\n            layoutInfo: layoutInfo,\n            corner: corner,\n            offset: offset\n          };\n        }\n      }\n    }\n    // No need to anchor the scroll position if it is at the top\n    if (visibleRect.y === 0 && !this.anchorScrollPositionAtTop) return null;\n    // Find a view with a visible corner that has the smallest distance to the top of the collection view\n    let cornerAnchor = null;\n    for (let [key, view] of this._visibleViews) {\n      let layoutInfo = view.layoutInfo;\n      if (layoutInfo && layoutInfo.rect.area > 0) {\n        let corner = layoutInfo.rect.getCornerInRect(visibleRect);\n        if (corner) {\n          let offset = layoutInfo.rect[corner].y - visibleRect.y;\n          if (!cornerAnchor || offset < cornerAnchor.offset) cornerAnchor = {\n            key: key,\n            layoutInfo: layoutInfo,\n            corner: corner,\n            offset: offset\n          };\n        }\n      }\n    }\n    return cornerAnchor;\n  }\n  _restoreScrollAnchor(scrollAnchor, context) {\n    let contentOffset = this.getVisibleRect();\n    if (scrollAnchor) {\n      var _context_transaction;\n      let finalAnchor = ((_context_transaction = context.transaction) === null || _context_transaction === void 0 ? void 0 : _context_transaction.animated) ? context.transaction.finalMap.get(scrollAnchor.key) : this.layout.getLayoutInfo(scrollAnchor.layoutInfo.key);\n      if (finalAnchor) {\n        let adjustment = finalAnchor.rect[scrollAnchor.corner].y - contentOffset.y - scrollAnchor.offset;\n        contentOffset.y += adjustment;\n      }\n    }\n    return contentOffset;\n  }\n  getVisibleRect() {\n    let v = this.visibleRect;\n    let x = v.x - this._animatedContentOffset.x;\n    let y = v.y - this._animatedContentOffset.y;\n    return new (0, $60423f92c7f9ad87$export$c79fc6492f3af13d)(x, y, v.width, v.height);\n  }\n  getVisibleLayoutInfos() {\n    let isTestEnv = false;\n    let isClientWidthMocked = Object.getOwnPropertyNames(window.HTMLElement.prototype).includes('clientWidth');\n    let isClientHeightMocked = Object.getOwnPropertyNames(window.HTMLElement.prototype).includes('clientHeight');\n    let rect;\n    if (isTestEnv && !(isClientWidthMocked && isClientHeightMocked)) rect = this._getContentRect();else rect = this.shouldOverscan ? this._overscanManager.getOverscannedRect() : this.getVisibleRect();\n    this._visibleLayoutInfos = this._getLayoutInfoMap(rect);\n    return this._visibleLayoutInfos;\n  }\n  _getLayoutInfoMap(rect, copy = false) {\n    let layoutInfos = this.layout.getVisibleLayoutInfos(rect);\n    let map = new Map();\n    for (let layoutInfo of layoutInfos) {\n      if (copy) layoutInfo = layoutInfo.copy();\n      map.set(layoutInfo.key, layoutInfo);\n    }\n    return map;\n  }\n  updateSubviews(forceUpdate = false) {\n    if (!this._collection) return;\n    let visibleLayoutInfos = this.getVisibleLayoutInfos();\n    let currentlyVisible = this._visibleViews;\n    let toAdd, toRemove, toUpdate;\n    // If this is a force update, remove and re-add all views.\n    // Otherwise, find and update the diff.\n    if (forceUpdate) {\n      toAdd = visibleLayoutInfos;\n      toRemove = currentlyVisible;\n      toUpdate = new Set();\n    } else {\n      ({\n        toAdd: toAdd,\n        toRemove: toRemove,\n        toUpdate: toUpdate\n      } = (0, $fc36f9a046a9ce79$export$acaf96a27438246b)(currentlyVisible, visibleLayoutInfos));\n      for (let key of toUpdate) {\n        let view = currentlyVisible.get(key);\n        if (!view || !view.layoutInfo) continue;\n        let item = this.getItem(visibleLayoutInfos.get(key).key);\n        if (view.content === item) toUpdate.delete(key);else {\n          // If the view type changes, delete and recreate the view instead of updating\n          let {\n            reuseType: reuseType\n          } = this._getReuseType(view.layoutInfo, item);\n          if (view.viewType !== reuseType) {\n            toUpdate.delete(key);\n            toAdd.add(key);\n            toRemove.add(key);\n          }\n        }\n      }\n      // We are done if the sets are equal\n      if (toAdd.size === 0 && toRemove.size === 0 && toUpdate.size === 0) {\n        if (this._transaction) this._applyLayoutInfos();\n        return;\n      }\n    }\n    // Track views that should be removed. They are not removed from\n    // the DOM immediately, since we may reuse and need to re-insert\n    // them back into the DOM anyway.\n    let removed = new Set();\n    for (let key of toRemove.keys()) {\n      let view = this._visibleViews.get(key);\n      if (view) {\n        removed.add(view);\n        this._visibleViews.delete(key);\n        // If we are in the middle of a transaction, wait until the end\n        // of the animations to remove the views from the DOM. Also means\n        // we can't reuse those views immediately.\n        if (this._transaction) this._transaction.toRemove.set(key, view);else this.reuseView(view);\n      }\n    }\n    for (let key of toAdd.keys()) {\n      let layoutInfo = visibleLayoutInfos.get(key);\n      let view;\n      // If we're in a transaction, and a layout change happens\n      // during the animations such that a view that was going\n      // to be removed is now not, we don't create a new view\n      // since the old one is still in the DOM, marked as toRemove.\n      if (this._transaction) {\n        // if transaction, get initial layout attributes for the animation\n        if (this._transaction.initialLayoutInfo.has(key)) layoutInfo = this._transaction.initialLayoutInfo.get(key);\n        view = this._transaction.toRemove.get(key);\n        if (view) {\n          this._transaction.toRemove.delete(key);\n          this._applyLayoutInfo(view, layoutInfo);\n        }\n      }\n      if (!view) {\n        // Create or reuse a view for this row\n        view = this.getReusableView(layoutInfo);\n        // Add the view to the DOM if needed\n        if (!removed.has(view)) this._children.add(view);\n      }\n      this._visibleViews.set(key, view);\n      removed.delete(view);\n    }\n    for (let key of toUpdate) {\n      let view = currentlyVisible.get(key);\n      this._renderedContent.delete(key);\n      this._renderView(view);\n    }\n    // Remove the remaining rows to delete from the DOM\n    if (!this._transaction) this.removeViews(removed);\n    this._correctItemOrder();\n    this._flushVisibleViews();\n    let hasLayoutUpdates = this._transaction && (toAdd.size > 0 || toRemove.size > 0 || this._hasLayoutUpdates());\n    if (hasLayoutUpdates) requestAnimationFrame(() => {\n      // If we're in a transaction, apply animations to visible views\n      // and \"to be removed\" views, which animate off screen.\n      if (this._transaction) requestAnimationFrame(() => this._applyLayoutInfos());\n    });\n    return hasLayoutUpdates;\n  }\n  afterRender() {\n    if (this._transactionQueue.length > 0) this._processTransactionQueue();else if (this._invalidationContext) this.relayoutNow();\n    if (this.shouldOverscan) this._overscanManager.collectMetrics();\n  }\n  _flushVisibleViews() {\n    // CollectionVirtualizer deals with a flattened set of LayoutInfos, but they can represent hierarchy\n    // by referencing a parentKey. Just before rendering the visible views, we rebuild this hierarchy\n    // by creating a mapping of views by parent key and recursively calling the delegate's renderWrapper\n    // method to build the final tree.\n    let viewsByParentKey = new Map([[null, []]]);\n    for (let view of this._children) {\n      var _view_layoutInfo, _viewsByParentKey_get, _view_layoutInfo1, _view_layoutInfo2, _view_layoutInfo3;\n      if (((_view_layoutInfo = view.layoutInfo) === null || _view_layoutInfo === void 0 ? void 0 : _view_layoutInfo.parentKey) != null && !viewsByParentKey.has(view.layoutInfo.parentKey)) viewsByParentKey.set(view.layoutInfo.parentKey, []);\n      (_viewsByParentKey_get = viewsByParentKey.get((_view_layoutInfo1 = view.layoutInfo) === null || _view_layoutInfo1 === void 0 ? void 0 : _view_layoutInfo1.parentKey)) === null || _viewsByParentKey_get === void 0 ? void 0 : _viewsByParentKey_get.push(view);\n      if (!viewsByParentKey.has((_view_layoutInfo2 = view.layoutInfo) === null || _view_layoutInfo2 === void 0 ? void 0 : _view_layoutInfo2.key)) viewsByParentKey.set((_view_layoutInfo3 = view.layoutInfo) === null || _view_layoutInfo3 === void 0 ? void 0 : _view_layoutInfo3.key, []);\n    }\n    let buildTree = (parent, views) => views.map(view => {\n      let children = viewsByParentKey.get(view.layoutInfo.key);\n      return this.delegate.renderWrapper(parent, view, children, childViews => buildTree(view, childViews));\n    });\n    let children = buildTree(null, viewsByParentKey.get(null));\n    this.delegate.setVisibleViews(children);\n  }\n  _applyLayoutInfo(view, layoutInfo) {\n    if (view.layoutInfo === layoutInfo) return false;\n    view.layoutInfo = layoutInfo;\n    return true;\n  }\n  _applyLayoutInfos() {\n    let updated = false;\n    // Apply layout infos to visible views\n    for (let view of this._visibleViews.values()) {\n      let cur = view.layoutInfo;\n      if ((cur === null || cur === void 0 ? void 0 : cur.key) != null) {\n        let layoutInfo = this.layout.getLayoutInfo(cur.key);\n        if (this._applyLayoutInfo(view, layoutInfo)) updated = true;\n      }\n    }\n    // Apply final layout infos for views that will be removed\n    if (this._transaction) {\n      for (let view of this._transaction.toRemove.values()) {\n        let cur = view.layoutInfo;\n        if ((cur === null || cur === void 0 ? void 0 : cur.key) != null) {\n          let layoutInfo = this.layout.getLayoutInfo(cur.key);\n          if (this._applyLayoutInfo(view, layoutInfo)) updated = true;\n        }\n      }\n      for (let view of this._transaction.removed.values()) {\n        let cur = view.layoutInfo;\n        let layoutInfo = this._transaction.finalLayoutInfo.get(cur.key) || cur;\n        layoutInfo = this.layout.getFinalLayoutInfo(layoutInfo.copy());\n        if (this._applyLayoutInfo(view, layoutInfo)) updated = true;\n      }\n    }\n    if (updated) this._flushVisibleViews();\n  }\n  _hasLayoutUpdates() {\n    if (!this._transaction) return false;\n    for (let view of this._visibleViews.values()) {\n      let cur = view.layoutInfo;\n      if (!cur) return true;\n      let layoutInfo = this.layout.getLayoutInfo(cur.key);\n      if (\n      // Uses equals rather than pointEquals so that width/height changes are taken into account\n      !cur.rect.equals(layoutInfo.rect) || cur.opacity !== layoutInfo.opacity || cur.transform !== layoutInfo.transform) return true;\n    }\n    return false;\n  }\n  reuseView(view) {\n    view.prepareForReuse();\n    this._reusableViews[view.viewType].push(view);\n  }\n  removeViews(toRemove) {\n    for (let view of toRemove) this._children.delete(view);\n  }\n  updateItemSize(key, size) {\n    // TODO: we should be able to invalidate a single index path\n    // @ts-ignore\n    if (!this.layout.updateItemSize) return;\n    // If the scroll position is currently animating, add the update\n    // to a queue to be processed after the animation is complete.\n    if (this._scrollAnimation) {\n      this._sizeUpdateQueue.set(key, size);\n      return;\n    }\n    // @ts-ignore\n    let changed = this.layout.updateItemSize(key, size);\n    if (changed) this.relayout();\n  }\n  startScrolling() {\n    this._isScrolling = true;\n  }\n  endScrolling() {\n    this._isScrolling = false;\n    this._correctItemOrder();\n    this._flushVisibleViews();\n  }\n  _resetAnimatedContentOffset() {\n    // Reset the animated content offset of subviews. See comment in relayoutNow for details.\n    if (!this._animatedContentOffset.isOrigin()) {\n      this._animatedContentOffset = new (0, $3041db3296945e6e$export$baf26146a414f24a)(0, 0);\n      this._applyLayoutInfos();\n    }\n  }\n  /**\n  * Scrolls the item with the given key into view, optionally with an animation.\n  * @param key The key of the item to scroll into view.\n  * @param duration The duration of the scroll animation.\n  */\n  scrollToItem(key, options) {\n    // key can be 0, so check if null or undefined\n    if (key == null) return;\n    let layoutInfo = this.layout.getLayoutInfo(key);\n    if (!layoutInfo) return;\n    let {\n      duration = 300,\n      shouldScrollX = true,\n      shouldScrollY = true,\n      offsetX = 0,\n      offsetY = 0\n    } = options;\n    let x = this.visibleRect.x;\n    let y = this.visibleRect.y;\n    let minX = layoutInfo.rect.x - offsetX;\n    let minY = layoutInfo.rect.y - offsetY;\n    let maxX = x + this.visibleRect.width;\n    let maxY = y + this.visibleRect.height;\n    if (shouldScrollX) {\n      if (minX <= x || maxX === 0) x = minX;else if (layoutInfo.rect.maxX > maxX) x += layoutInfo.rect.maxX - maxX;\n    }\n    if (shouldScrollY) {\n      if (minY <= y || maxY === 0) y = minY;else if (layoutInfo.rect.maxY > maxY) y += layoutInfo.rect.maxY - maxY;\n    }\n    return this.scrollTo(new (0, $3041db3296945e6e$export$baf26146a414f24a)(x, y), duration);\n  }\n  /**\n  * Performs an animated scroll to the given offset.\n  * @param offset - The offset to scroll to.\n  * @param duration The duration of the animation.\n  * @returns A promise that resolves when the animation is complete.\n  */\n  scrollTo(offset, duration = 300) {\n    // Cancel the current scroll animation\n    if (this._scrollAnimation) {\n      this._scrollAnimation.cancel();\n      this._scrollAnimation = null;\n    }\n    // Set the content offset synchronously if the duration is zero\n    if (duration <= 0 || this.visibleRect.pointEquals(offset)) {\n      this._setContentOffset(offset);\n      return Promise.resolve();\n    }\n    this.startScrolling();\n    this._scrollAnimation = (0, $3eb131dcf37ad5f8$export$dc0b63720788090c)(this.visibleRect, offset, duration, (0, $3eb131dcf37ad5f8$export$57636bb43b1ccbb0), offset => {\n      this._setContentOffset(offset);\n    });\n    this._scrollAnimation.then(() => {\n      this._scrollAnimation = null;\n      // Process view size updates that occurred during the animation.\n      // Only views that are still visible will be actually updated.\n      for (let [key, size] of this._sizeUpdateQueue) this.updateItemSize(key, size);\n      this._sizeUpdateQueue.clear();\n      this.relayout();\n      this._processTransactionQueue();\n      this.endScrolling();\n    });\n    return this._scrollAnimation;\n  }\n  _runTransaction(action, animated) {\n    this._startTransaction();\n    if (this._nextTransaction) this._nextTransaction.actions.push(action);\n    this._endTransaction(animated);\n  }\n  _startTransaction() {\n    if (!this._nextTransaction) this._nextTransaction = new (0, $8e135e531d8dcb66$export$febc5573c75cefb0)();\n    this._nextTransaction.level++;\n  }\n  _endTransaction(animated) {\n    if (!this._nextTransaction) return false;\n    // Save whether the transaction should be animated.\n    if (animated != null) this._nextTransaction.animated = animated;\n    // If we haven't reached level 0, we are still in a\n    // nested transaction. Wait for the parent to end.\n    if (--this._nextTransaction.level > 0) return false;\n    // Do nothing for empty transactions\n    if (this._nextTransaction.actions.length === 0) {\n      this._nextTransaction = null;\n      return false;\n    }\n    // Default animations to true\n    if (this._nextTransaction.animated == null) this._nextTransaction.animated = true;\n    // Enqueue the transaction\n    this._transactionQueue.push(this._nextTransaction);\n    this._nextTransaction = null;\n    return true;\n  }\n  _processTransactionQueue() {\n    // If the current transaction is animating, wait until the end\n    // to process the next transaction.\n    if (this._transaction || this._scrollAnimation) return;\n    let next = this._transactionQueue.shift();\n    if (next) this._performTransaction(next);\n  }\n  _getContentRect() {\n    return new (0, $60423f92c7f9ad87$export$c79fc6492f3af13d)(0, 0, this.contentSize.width, this.contentSize.height);\n  }\n  _performTransaction(transaction) {\n    this._transaction = transaction;\n    this.relayoutNow({\n      transaction: transaction,\n      animated: transaction.animated,\n      beforeLayout: () => {\n        // Get the initial layout infos for all views before the updates\n        // so we can figure out which views to add and remove.\n        if (transaction.animated) transaction.initialMap = this._getLayoutInfoMap(this._getContentRect(), true);\n        // Apply the actions that occurred during this transaction\n        for (let action of transaction.actions) action();\n      },\n      afterLayout: () => {\n        // Get the final layout infos after the updates\n        if (transaction.animated) {\n          transaction.finalMap = this._getLayoutInfoMap(this._getContentRect());\n          this._setupTransactionAnimations(transaction);\n        } else this._transaction = null;\n      },\n      afterAnimation: () => {\n        // Remove and reuse views when animations are done\n        if (transaction.toRemove.size > 0 || transaction.removed.size > 0) for (let view of (0, $fc36f9a046a9ce79$export$cfc14088dfefce5f)(transaction.toRemove.values(), transaction.removed.values())) {\n          this._children.delete(view);\n          this.reuseView(view);\n        }\n        this._transaction = null;\n        // Ensure DOM order is correct for accessibility after animations are complete\n        this._correctItemOrder();\n        this._flushVisibleViews();\n        this._processTransactionQueue();\n      }\n    });\n  }\n  _setupTransactionAnimations(transaction) {\n    let {\n      initialMap: initialMap,\n      finalMap: finalMap\n    } = transaction;\n    // Store initial and final layout infos for animations\n    for (let [key, layoutInfo] of initialMap) if (finalMap.has(key))\n      // Store the initial layout info for use during animations.\n      transaction.initialLayoutInfo.set(key, layoutInfo);else\n      // This view was removed. Store the layout info for use\n      // in Layout#getFinalLayoutInfo during animations.\n      transaction.finalLayoutInfo.set(layoutInfo.key, layoutInfo);\n    // Get initial layout infos for views that were added\n    for (let [key, layoutInfo] of finalMap) if (!initialMap.has(key)) {\n      let initialLayoutInfo = this.layout.getInitialLayoutInfo(layoutInfo.copy());\n      transaction.initialLayoutInfo.set(key, initialLayoutInfo);\n    }\n    // Figure out which views were removed.\n    for (let [key, view] of this._visibleViews)\n    // If an item has a width of 0, there is no need to remove it from the _visibleViews.\n    // Removing an item with  width of 0 can cause a loop where the item gets added, removed,\n    // added, removed... etc in a loop.\n    if (!finalMap.has(key) && view.layoutInfo.rect.width > 0) {\n      transaction.removed.set(key, view);\n      this._visibleViews.delete(key);\n      // In case something weird happened, where we have a view but no\n      // initial layout info, use the one attached to the view.\n      if (view.layoutInfo) {\n        if (!transaction.finalLayoutInfo.has(view.layoutInfo.key)) transaction.finalLayoutInfo.set(view.layoutInfo.key, view.layoutInfo);\n      }\n    }\n  }\n  constructor(options = {}) {\n    this._contentSize = new (0, $ee1bfa90a957fb8a$export$cb6da89c6af1a8ec)();\n    this._visibleRect = new (0, $60423f92c7f9ad87$export$c79fc6492f3af13d)();\n    this._reusableViews = {};\n    this._visibleLayoutInfos = new Map();\n    this._visibleViews = new Map();\n    this._renderedContent = new WeakMap();\n    this._children = new Set();\n    this._invalidationContext = null;\n    this._overscanManager = new (0, $364191b3decf3697$export$4455ee6afb38dcbb)();\n    this._persistedKeys = new Set();\n    this._scrollAnimation = null;\n    this._isScrolling = false;\n    this._sizeUpdateQueue = new Map();\n    this._animatedContentOffset = new (0, $3041db3296945e6e$export$baf26146a414f24a)(0, 0);\n    this._transaction = null;\n    this._nextTransaction = null;\n    this._transactionQueue = [];\n    var _options_transitionDuration;\n    // Set options from passed object if given\n    this.transitionDuration = (_options_transitionDuration = options.transitionDuration) !== null && _options_transitionDuration !== void 0 ? _options_transitionDuration : 500;\n    this.anchorScrollPosition = options.anchorScrollPosition || false;\n    this.anchorScrollPositionAtTop = options.anchorScrollPositionAtTop || false;\n    this.shouldOverscan = options.shouldOverscan !== false;\n    for (let key of ['delegate', 'size', 'layout', 'collection']) if (options[key]) this[key] = options[key];\n  }\n}\nexport { $38b9490c1cca8fc4$export$89be5a243e59c4b2 as Virtualizer };","map":{"version":3,"names":["$38b9490c1cca8fc4$export$89be5a243e59c4b2","_setContentSize","size","_contentSize","delegate","setContentSize","_setContentOffset","offset","rect","$60423f92c7f9ad87$export$c79fc6492f3af13d","x","y","_visibleRect","width","height","setVisibleRect","contentSize","visibleRect","_setVisibleRect","forceUpdate","current","equals","shouldOverscan","_overscanManager","shouldInvalidate","layout","_resetAnimatedContentOffset","relayoutNow","offsetChanged","pointEquals","sizeChanged","sizeEquals","updateSubviews","collection","_collection","data","_setData","_runTransaction","transitionDuration","reloadData","relayout","contentChanged","getItem","key","persistedKeys","_persistedKeys","$fc36f9a046a9ce79$export$a8d0d0c8d1c5df64","isPersistedKey","has","k","layoutInfo","getLayoutInfo","parentKey","_layout","setLayout","animated","applyLayout","virtualizer","_getReuseType","content","type","getType","reuseType","getReusableView","_reusableViews","reusable","view","length","pop","$ad1d98aa8f0c31b4$export$1a5223887c560441","viewType","_animatedContentOffset","isOrigin","copy","_renderView","reusableView","rendered","_renderContent","cached","_renderedContent","get","renderView","set","visibleViews","Array","from","_visibleViews","values","getView","getViewsOfType","filter","v","keyForView","keyAtPoint","point","layoutInfos","getVisibleLayoutInfos","intersects","willUnmount","cancelAnimationFrame","_relayoutRaf","context","_scrollAnimation","requestAnimationFrame","_invalidationContext","Object","assign","scrollAnchor","_getScrollAnchor","beforeLayout","validate","getContentSize","afterLayout","getVisibleRect","restoredScrollAnchor","_restoreScrollAnchor","contentOffsetX","contentOffsetY","Math","max","min","hasLayoutUpdates","$3041db3296945e6e$export$baf26146a414f24a","transaction","_applyLayoutInfos","_enableTransitions","done","_disableTransitions","afterAnimation","setTimeout","_correctItemOrder","_isScrolling","_transaction","_visibleLayoutInfos","keys","_children","delete","add","beginAnimations","endAnimations","anchorScrollPosition","getScrollAnchor","corner","getCornerInRect","anchorScrollPositionAtTop","cornerAnchor","area","contentOffset","_context_transaction","finalAnchor","finalMap","adjustment","isTestEnv","isClientWidthMocked","getOwnPropertyNames","window","HTMLElement","prototype","includes","isClientHeightMocked","_getContentRect","getOverscannedRect","_getLayoutInfoMap","map","Map","visibleLayoutInfos","currentlyVisible","toAdd","toRemove","toUpdate","Set","$fc36f9a046a9ce79$export$acaf96a27438246b","item","removed","reuseView","initialLayoutInfo","_applyLayoutInfo","removeViews","_flushVisibleViews","_hasLayoutUpdates","afterRender","_transactionQueue","_processTransactionQueue","collectMetrics","viewsByParentKey","_view_layoutInfo","_viewsByParentKey_get","_view_layoutInfo1","_view_layoutInfo2","_view_layoutInfo3","push","buildTree","parent","views","children","renderWrapper","childViews","setVisibleViews","updated","cur","finalLayoutInfo","getFinalLayoutInfo","opacity","transform","prepareForReuse","updateItemSize","_sizeUpdateQueue","changed","startScrolling","endScrolling","scrollToItem","options","duration","shouldScrollX","shouldScrollY","offsetX","offsetY","minX","minY","maxX","maxY","scrollTo","cancel","Promise","resolve","$3eb131dcf37ad5f8$export$dc0b63720788090c","$3eb131dcf37ad5f8$export$57636bb43b1ccbb0","then","clear","action","_startTransaction","_nextTransaction","actions","_endTransaction","$8e135e531d8dcb66$export$febc5573c75cefb0","level","next","shift","_performTransaction","initialMap","_setupTransactionAnimations","$fc36f9a046a9ce79$export$cfc14088dfefce5f","getInitialLayoutInfo","constructor","$ee1bfa90a957fb8a$export$cb6da89c6af1a8ec","WeakMap","$364191b3decf3697$export$4455ee6afb38dcbb","_options_transitionDuration"],"sources":["/Users/mario/Documents/pythonmongoreact/soldini/soldini-front/node_modules/@react-stately/virtualizer/dist/packages/@react-stately/virtualizer/src/Virtualizer.ts"],"sourcesContent":["/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nimport {CancelablePromise, easeOut, tween} from './tween';\nimport {Collection, Key} from '@react-types/shared';\nimport {concatIterators, difference, isSetEqual} from './utils';\nimport {\n  InvalidationContext,\n  ScrollAnchor,\n  ScrollToItemOptions,\n  VirtualizerDelegate,\n  VirtualizerOptions\n} from './types';\nimport {Layout} from './Layout';\nimport {LayoutInfo} from './LayoutInfo';\nimport {OverscanManager} from './OverscanManager';\nimport {Point} from './Point';\nimport {Rect} from './Rect';\nimport {ReusableView} from './ReusableView';\nimport {Size} from './Size';\nimport {Transaction} from './Transaction';\n\n/**\n * The CollectionView class renders a scrollable collection of data using customizable layouts,\n * and manages animated updates to the data over time. It supports very large collections by\n * only rendering visible views to the DOM, reusing them as you scroll. Collection views can\n * present any type of view, including non-item views such as section headers and footers.\n * Optionally, the {@link EditableCollectionView} subclass can be used to enable user interaction\n * with the collection, including drag and drop, multiple selection, and keyboard interacton.\n *\n * Collection views get their data from a {@link DataSource} object that you provide. Items are\n * grouped into sections by the data source, and the collection view calls its methods to retrieve\n * the data. When data changes, the data source emits change events, and the collection view\n * updates as appropriate, optionally with an animated transition. There is one built-in data source\n * implementation, {@link ArrayDataSource}, which renders content from a 2d array.\n *\n * Collection views use {@link Layout} objects to compute what views should be visible, and how\n * to position and style them. This means that collection views can have their items arranged in\n * a stack, a grid, a circle, or any other layout you can think of. The layout can be changed\n * dynamically at runtime as well, optionally with an animated transition between the layouts.\n *\n * Layouts produce information on what views should appear in the collection view, but do not create\n * the views themselves directly. It is the responsibility of the {@link CollectionViewDelegate} object\n * to create instances of {@link ReusableView} subclasses which render the items into DOM nodes.\n * The delegate determines what type of view to display for each item, and creates instances of\n * views as needed by the collection view. Those views are then reused by the collection view as\n * the user scrolls through the content.\n */\nexport class Virtualizer<T extends object, V, W> {\n  /**\n   * The collection view delegate. The delegate is used by the collection view\n   * to create and configure views.\n   */\n  delegate: VirtualizerDelegate<T, V, W>;\n\n  /** The duration of animated layout changes, in milliseconds. Default is 500ms. */\n  transitionDuration: number;\n\n  /**\n   * Whether to enable scroll anchoring. This will attempt to restore the scroll position\n   * after layout changes outside the viewport. Default is off.\n   */\n  anchorScrollPosition: boolean;\n\n  /** Whether to anchor the scroll position when at the top of the content. Default is off. */\n  anchorScrollPositionAtTop: boolean;\n\n  /**\n   * Whether to overscan the visible area to pre-render items slightly outside and\n   * improve performance. Default is on.\n   */\n  shouldOverscan: boolean;\n\n  private _collection: Collection<T>;\n  private _layout: Layout<T>;\n  private _contentSize: Size;\n  private _visibleRect: Rect;\n  private _visibleLayoutInfos: Map<Key, LayoutInfo>;\n  private _reusableViews: {[type: string]: ReusableView<T, V>[]};\n  private _visibleViews: Map<Key, ReusableView<T, V>>;\n  private _renderedContent: WeakMap<T, V>;\n  private _children: Set<ReusableView<T, V>>;\n  private _invalidationContext: InvalidationContext<T, V> | null;\n  private _overscanManager: OverscanManager;\n  private _persistedKeys: Set<Key>;\n  private _relayoutRaf: number | null;\n  private _scrollAnimation: CancelablePromise<void> | null;\n  private _isScrolling: boolean;\n  private _sizeUpdateQueue: Map<Key, Size>;\n  private _animatedContentOffset: Point;\n  private _transaction: Transaction<T, V> | null;\n  private _nextTransaction: Transaction<T, V> | null;\n  private _transactionQueue: Transaction<T, V>[];\n\n  constructor(options: VirtualizerOptions<T, V, W> = {}) {\n    this._contentSize = new Size;\n    this._visibleRect = new Rect;\n\n    this._reusableViews = {};\n    this._visibleLayoutInfos = new Map();\n    this._visibleViews = new Map();\n    this._renderedContent = new WeakMap();\n    this._children = new Set();\n    this._invalidationContext = null;\n    this._overscanManager = new OverscanManager();\n    this._persistedKeys = new Set();\n\n    this._scrollAnimation = null;\n    this._isScrolling = false;\n    this._sizeUpdateQueue = new Map();\n    this._animatedContentOffset = new Point(0, 0);\n\n    this._transaction = null;\n    this._nextTransaction = null;\n    this._transactionQueue = [];\n\n    // Set options from passed object if given\n    this.transitionDuration = options.transitionDuration ?? 500;\n    this.anchorScrollPosition = options.anchorScrollPosition || false;\n    this.anchorScrollPositionAtTop = options.anchorScrollPositionAtTop || false;\n    this.shouldOverscan = options.shouldOverscan !== false;\n    for (let key of ['delegate', 'size', 'layout', 'collection']) {\n      if (options[key]) {\n        this[key] = options[key];\n      }\n    }\n  }\n\n  _setContentSize(size: Size) {\n    this._contentSize = size;\n    this.delegate.setContentSize(size);\n  }\n\n  _setContentOffset(offset: Point) {\n    let rect = new Rect(offset.x, offset.y, this._visibleRect.width, this._visibleRect.height);\n    this.delegate.setVisibleRect(rect);\n  }\n\n  /**\n   * Get the size of the scrollable content.\n   */\n  get contentSize(): Size {\n    return this._contentSize;\n  }\n\n  /**\n   * Get the collection view's currently visible rectangle.\n   */\n  get visibleRect(): Rect {\n    return this._visibleRect;\n  }\n\n  /**\n   * Set the collection view's currently visible rectangle.\n   */\n  set visibleRect(rect: Rect) {\n    this._setVisibleRect(rect);\n  }\n\n  _setVisibleRect(rect: Rect, forceUpdate = false) {\n    let current = this._visibleRect;\n\n    // Ignore if the rects are equal\n    if (rect.equals(current)) {\n      return;\n    }\n\n    if (this.shouldOverscan) {\n      this._overscanManager.setVisibleRect(rect);\n    }\n\n    let shouldInvalidate = this.layout && this.layout.shouldInvalidate(rect, this._visibleRect);\n\n    this._resetAnimatedContentOffset();\n    this._visibleRect = rect;\n\n    if (shouldInvalidate) {\n      // We are already in a layout effect when this method is called, so relayoutNow is appropriate.\n      this.relayoutNow({\n        offsetChanged: !rect.pointEquals(current),\n        sizeChanged: !rect.sizeEquals(current)\n      });\n    } else {\n      this.updateSubviews(forceUpdate);\n    }\n  }\n\n  get collection(): Collection<T> {\n    return this._collection;\n  }\n\n  set collection(data: Collection<T>) {\n    this._setData(data);\n  }\n\n  private _setData(data: Collection<T>) {\n    if (data === this._collection) {\n      return;\n    }\n\n    if (this._collection) {\n      this._runTransaction(() => {\n        this._collection = data;\n      }, this.transitionDuration > 0);\n    } else {\n      this._collection = data;\n      this.reloadData();\n    }\n  }\n\n  /**\n   * Reloads the data from the data source and relayouts the collection view.\n   * Does not animate any changes. Equivalent to re-assigning the same data source\n   * to the collection view.\n   */\n  reloadData() {\n    this.relayout({\n      contentChanged: true\n    });\n  }\n\n  /**\n   * Returns the item with the given key.\n   */\n  getItem(key: Key) {\n    return this._collection ? this._collection.getItem(key) : null;\n  }\n\n  /** The set of persisted keys are always present in the DOM, even if not currently in view. */\n  get persistedKeys(): Set<Key> {\n    return this._persistedKeys;\n  }\n\n  /** The set of persisted keys are always present in the DOM, even if not currently in view. */\n  set persistedKeys(persistedKeys: Set<Key>) {\n    if (!isSetEqual(persistedKeys, this._persistedKeys)) {\n      this._persistedKeys = persistedKeys;\n      this.updateSubviews();\n    }\n  }\n\n  /** Returns whether the given key, or an ancestor, is persisted. */\n  isPersistedKey(key: Key) {\n    // Quick check if the key is directly in the set of persisted keys.\n    if (this._persistedKeys.has(key)) {\n      return true;\n    }\n\n    // If not, check if the key is an ancestor of any of the persisted keys.\n    for (let k of this._persistedKeys) {\n      while (k != null) {\n        let layoutInfo = this.layout.getLayoutInfo(k);\n        if (!layoutInfo) {\n          break;\n        }\n\n        k = layoutInfo.parentKey;\n\n        if (k === key) {\n          return true;\n        }\n      }\n    }\n\n    return false;\n  }\n\n  /**\n   * Get the collection view's layout.\n   */\n  get layout(): Layout<T> {\n    return this._layout;\n  }\n\n  /**\n   * Set the collection view's layout.\n   */\n  set layout(layout: Layout<T>) {\n    this.setLayout(layout);\n  }\n\n  /**\n   * Sets the collection view's layout, optionally with an animated transition\n   * from the current layout to the new layout.\n   * @param layout The layout to switch to.\n   * @param animated Whether to animate the layout change.\n   */\n  setLayout(layout: Layout<T>, animated = false) {\n    if (layout === this._layout) {\n      return;\n    }\n\n    let applyLayout = () => {\n      if (this._layout) {\n        // @ts-ignore\n        this._layout.virtualizer = null;\n      }\n\n      layout.virtualizer = this;\n      this._layout = layout;\n    };\n\n    if (animated) {\n      // Animated layout transitions are really simple, thanks to our transaction support.\n      // We just set the layout inside a transaction action, which runs after the initial\n      // layout infos for the animation are retrieved from the previous layout. Then, the\n      // final layout infos are retrieved from the new layout, and animations occur.\n      this._runTransaction(applyLayout);\n    } else {\n      applyLayout();\n      this.relayout();\n    }\n  }\n\n  private _getReuseType(layoutInfo: LayoutInfo, content: T | null) {\n    if (layoutInfo.type === 'item' && content) {\n      let type = this.delegate.getType ? this.delegate.getType(content) : 'item';\n      let reuseType = type === 'item' ? 'item' : layoutInfo.type + '_' + type;\n      return {type, reuseType};\n    }\n\n    return {\n      type: layoutInfo.type,\n      reuseType: layoutInfo.type\n    };\n  }\n\n  getReusableView(layoutInfo: LayoutInfo): ReusableView<T, V> {\n    let content = this.getItem(layoutInfo.key);\n    let {reuseType} = this._getReuseType(layoutInfo, content);\n\n    if (!this._reusableViews[reuseType]) {\n      this._reusableViews[reuseType] = [];\n    }\n\n    let reusable = this._reusableViews[reuseType];\n    let view = reusable.length > 0\n      ? reusable.pop()\n      : new ReusableView<T, V>(this);\n\n    view.viewType = reuseType;\n\n    if (!this._animatedContentOffset.isOrigin()) {\n      layoutInfo = layoutInfo.copy();\n      layoutInfo.rect.x += this._animatedContentOffset.x;\n      layoutInfo.rect.y += this._animatedContentOffset.y;\n    }\n\n    view.layoutInfo = layoutInfo;\n\n    this._renderView(view);\n    return view;\n  }\n\n  private _renderView(reusableView: ReusableView<T, V>) {\n    let {type, key} = reusableView.layoutInfo;\n    reusableView.content = this.getItem(key);\n    reusableView.rendered = this._renderContent(type, reusableView.content);\n  }\n\n  private _renderContent(type: string, content: T) {\n    let cached = this._renderedContent.get(content);\n    if (cached != null) {\n      return cached;\n    }\n\n    let rendered = this.delegate.renderView(type, content);\n    if (content) {\n      this._renderedContent.set(content, rendered);\n    }\n    return rendered;\n  }\n\n  /**\n   * Returns an array of all currently visible views, including both\n   * item views and supplementary views.\n   */\n  get visibleViews(): ReusableView<T, V>[] {\n    return Array.from(this._visibleViews.values());\n  }\n\n  /**\n   * Gets the visible view for the given type and key. Returns null if\n   * the view is not currently visible.\n   *\n   * @param key The key of the view to retrieve.\n   */\n  getView(key: Key): ReusableView<T, V> | null {\n    return this._visibleViews.get(key) || null;\n  }\n\n  /**\n   * Returns an array of visible views matching the given type.\n   * @param type The view type to find.\n   */\n  getViewsOfType(type: string): ReusableView<T, V>[] {\n    return this.visibleViews.filter(v => v.layoutInfo && v.layoutInfo.type === type);\n  }\n\n  /**\n   * Returns the key for the given view. Returns null\n   * if the view is not currently visible.\n   */\n  keyForView(view: ReusableView<T, V>): Key | null {\n    if (view && view.layoutInfo) {\n      return view.layoutInfo.key;\n    }\n\n    return null;\n  }\n\n  /**\n   * Returns the key for the item view currently at the given point.\n   */\n  keyAtPoint(point: Point): Key | null {\n    let rect = new Rect(point.x, point.y, 1, 1);\n    let layoutInfos = this.layout.getVisibleLayoutInfos(rect);\n\n    // Layout may return multiple layout infos in the case of\n    // persisted keys, so find the first one that actually intersects.\n    for (let layoutInfo of layoutInfos) {\n      if (layoutInfo.rect.intersects(rect)) {\n        return layoutInfo.key;\n      }\n    }\n\n    return null;\n  }\n\n  /**\n   * Cleanup for when the Virtualizer will be unmounted.\n   */\n  willUnmount() {\n    cancelAnimationFrame(this._relayoutRaf);\n  }\n\n  /**\n   * Triggers a layout invalidation, and updates the visible subviews.\n   */\n  relayout(context: InvalidationContext<T, V> = {}) {\n    // Ignore relayouts while animating the scroll position\n    if (this._scrollAnimation || typeof requestAnimationFrame === 'undefined') {\n      return;\n    }\n\n    // If we already scheduled a relayout, extend the invalidation\n    // context so we coalesce multiple relayouts in the same frame.\n    if (this._invalidationContext) {\n      Object.assign(this._invalidationContext, context);\n      return;\n    }\n\n    this._invalidationContext = context;\n  }\n\n  /**\n   * Performs a relayout immediately. Prefer {@link relayout} over this method\n   * where possible, since it coalesces multiple layout passes in the same tick.\n   */\n  relayoutNow(context: InvalidationContext<T, V> = this._invalidationContext || {}) {\n    // Cancel the scheduled relayout, since we're doing it now.\n    if (this._relayoutRaf) {\n      cancelAnimationFrame(this._relayoutRaf);\n      this._relayoutRaf = null;\n      // Update the provided context with the current invalidationContext since we are cancelling\n      // a scheduled relayoutNow call that has this._invalidationContext set as its default context arg (relayoutNow() in relayout)\n      context = {...this._invalidationContext, ...context};\n    }\n\n    // Reset the invalidation context\n    this._invalidationContext = null;\n\n    // Do nothing if we don't have a layout or content, or we are\n    // in the middle of an animated scroll transition.\n    if (!this.layout || !this._collection || this._scrollAnimation) {\n      return;\n    }\n\n    let scrollAnchor = this._getScrollAnchor();\n\n    // Trigger the beforeLayout hook, if provided\n    if (typeof context.beforeLayout === 'function') {\n      context.beforeLayout();\n    }\n\n    // Validate the layout\n    this.layout.validate(context);\n    this._setContentSize(this.layout.getContentSize());\n\n    // Trigger the afterLayout hook, if provided\n    if (typeof context.afterLayout === 'function') {\n      context.afterLayout();\n    }\n\n    // Adjust scroll position based on scroll anchor, and constrain.\n    // If the content changed, scroll to the top.\n    let visibleRect = this.getVisibleRect();\n    let restoredScrollAnchor = this._restoreScrollAnchor(scrollAnchor, context);\n    let contentOffsetX = context.contentChanged ? 0 : restoredScrollAnchor.x;\n    let contentOffsetY = context.contentChanged ? 0 : restoredScrollAnchor.y;\n    contentOffsetX = Math.max(0, Math.min(this.contentSize.width - visibleRect.width, contentOffsetX));\n    contentOffsetY = Math.max(0, Math.min(this.contentSize.height - visibleRect.height, contentOffsetY));\n\n    let hasLayoutUpdates = false;\n    if (contentOffsetX !== visibleRect.x || contentOffsetY !== visibleRect.y) {\n      // If this is an animated relayout, we do not immediately scroll because it would be jittery.\n      // Save the difference between the current and new content offsets, and apply it to the\n      // individual content items instead. At the end of the animation, we'll reset and set the\n      // scroll offset for real. This ensures jitter-free animation since we don't need to sync\n      // the scroll animation and the content animation.\n      if (context.animated || !this._animatedContentOffset.isOrigin()) {\n        this._animatedContentOffset.x += visibleRect.x - contentOffsetX;\n        this._animatedContentOffset.y += visibleRect.y - contentOffsetY;\n        hasLayoutUpdates = this.updateSubviews(context.contentChanged);\n      } else {\n        this._setContentOffset(new Point(contentOffsetX, contentOffsetY));\n      }\n    } else {\n      hasLayoutUpdates = this.updateSubviews(context.contentChanged);\n    }\n\n    // Apply layout infos, unless this is coming from an animated transaction\n    if (!(context.transaction && context.animated)) {\n      this._applyLayoutInfos();\n    }\n\n    // Wait for animations, and apply the afterAnimation hook, if provided\n    if (context.animated && hasLayoutUpdates) {\n      this._enableTransitions();\n\n      let done = () => {\n        this._disableTransitions();\n\n        // Reset scroll position after animations (see above comment).\n        if (!this._animatedContentOffset.isOrigin()) {\n          // Get the content offset to scroll to, taking _animatedContentOffset into account.\n          let {x, y} = this.getVisibleRect();\n          this._resetAnimatedContentOffset();\n          this._setContentOffset(new Point(x, y));\n        }\n\n        if (typeof context.afterAnimation === 'function') {\n          context.afterAnimation();\n        }\n      };\n\n      // Sometimes the animation takes slightly longer than expected.\n      setTimeout(done, this.transitionDuration + 100);\n      return;\n    } else if (typeof context.afterAnimation === 'function') {\n      context.afterAnimation();\n    }\n  }\n\n  /**\n   * Corrects DOM order of visible views to match item order of collection.\n   */\n  private _correctItemOrder() {\n    // Defer until after scrolling and animated transactions are complete\n    if (this._isScrolling || this._transaction) {\n      return;\n    }\n\n    for (let key of this._visibleLayoutInfos.keys()) {\n      let view = this._visibleViews.get(key);\n      this._children.delete(view);\n      this._children.add(view);\n    }\n  }\n\n  private _enableTransitions() {\n    this.delegate.beginAnimations();\n  }\n\n  private _disableTransitions() {\n    this.delegate.endAnimations();\n  }\n\n  private _getScrollAnchor(): ScrollAnchor | null {\n    if (!this.anchorScrollPosition) {\n      return null;\n    }\n\n    let visibleRect = this.getVisibleRect();\n\n    // Ask the delegate to provide a scroll anchor, if possible\n    if (this.delegate.getScrollAnchor) {\n      let key = this.delegate.getScrollAnchor(visibleRect);\n      if (key != null) {\n        let layoutInfo = this.layout.getLayoutInfo(key);\n        let corner = layoutInfo.rect.getCornerInRect(visibleRect);\n        if (corner) {\n          let key = layoutInfo.key;\n          let offset = layoutInfo.rect[corner].y - visibleRect.y;\n          return {key, layoutInfo, corner, offset};\n        }\n      }\n    }\n\n    // No need to anchor the scroll position if it is at the top\n    if (visibleRect.y === 0 && !this.anchorScrollPositionAtTop) {\n      return null;\n    }\n\n    // Find a view with a visible corner that has the smallest distance to the top of the collection view\n    let cornerAnchor: ScrollAnchor | null = null;\n\n    for (let [key, view] of this._visibleViews) {\n      let layoutInfo = view.layoutInfo;\n      if (layoutInfo && layoutInfo.rect.area > 0) {\n        let corner = layoutInfo.rect.getCornerInRect(visibleRect);\n\n        if (corner) {\n          let offset = layoutInfo.rect[corner].y - visibleRect.y;\n          if (!cornerAnchor || (offset < cornerAnchor.offset)) {\n            cornerAnchor = {key, layoutInfo, corner, offset};\n          }\n        }\n      }\n    }\n\n    return cornerAnchor;\n  }\n\n  private _restoreScrollAnchor(scrollAnchor: ScrollAnchor | null, context: InvalidationContext<T, V>) {\n    let contentOffset = this.getVisibleRect();\n\n    if (scrollAnchor) {\n      let finalAnchor = context.transaction?.animated\n        ? context.transaction.finalMap.get(scrollAnchor.key)\n        : this.layout.getLayoutInfo(scrollAnchor.layoutInfo.key);\n\n      if (finalAnchor) {\n        let adjustment = (finalAnchor.rect[scrollAnchor.corner].y - contentOffset.y) - scrollAnchor.offset;\n        contentOffset.y += adjustment;\n      }\n    }\n\n    return contentOffset;\n  }\n\n  getVisibleRect(): Rect {\n    let v = this.visibleRect;\n    let x = v.x - this._animatedContentOffset.x;\n    let y = v.y - this._animatedContentOffset.y;\n    return new Rect(x, y, v.width, v.height);\n  }\n\n  getVisibleLayoutInfos() {\n    let isTestEnv = process.env.NODE_ENV === 'test' && !process.env.VIRT_ON;\n\n    let isClientWidthMocked = Object.getOwnPropertyNames(window.HTMLElement.prototype).includes('clientWidth');\n    let isClientHeightMocked = Object.getOwnPropertyNames(window.HTMLElement.prototype).includes('clientHeight');\n\n    let rect;\n    if (isTestEnv && !(isClientWidthMocked && isClientHeightMocked)) {\n      rect = this._getContentRect();\n    } else {\n      rect = this.shouldOverscan ? this._overscanManager.getOverscannedRect() : this.getVisibleRect();\n    }\n\n    this._visibleLayoutInfos = this._getLayoutInfoMap(rect);\n    return this._visibleLayoutInfos;\n  }\n\n  private _getLayoutInfoMap(rect: Rect, copy = false) {\n    let layoutInfos = this.layout.getVisibleLayoutInfos(rect);\n    let map = new Map;\n\n    for (let layoutInfo of layoutInfos) {\n      if (copy) {\n        layoutInfo = layoutInfo.copy();\n      }\n\n      map.set(layoutInfo.key, layoutInfo);\n    }\n\n    return map;\n  }\n\n  updateSubviews(forceUpdate = false) {\n    if (!this._collection) {\n      return;\n    }\n\n    let visibleLayoutInfos = this.getVisibleLayoutInfos();\n    let currentlyVisible = this._visibleViews;\n    let toAdd, toRemove, toUpdate;\n\n    // If this is a force update, remove and re-add all views.\n    // Otherwise, find and update the diff.\n    if (forceUpdate) {\n      toAdd = visibleLayoutInfos;\n      toRemove = currentlyVisible;\n      toUpdate = new Set();\n    } else {\n      ({toAdd, toRemove, toUpdate} = difference(currentlyVisible, visibleLayoutInfos));\n\n      for (let key of toUpdate) {\n        let view = currentlyVisible.get(key);\n        if (!view || !view.layoutInfo) {\n          continue;\n        }\n\n        let item = this.getItem(visibleLayoutInfos.get(key).key);\n        if (view.content === item) {\n          toUpdate.delete(key);\n        } else {\n          // If the view type changes, delete and recreate the view instead of updating\n          let {reuseType} = this._getReuseType(view.layoutInfo, item);\n          if (view.viewType !== reuseType) {\n            toUpdate.delete(key);\n            toAdd.add(key);\n            toRemove.add(key);\n          }\n        }\n      }\n\n      // We are done if the sets are equal\n      if (toAdd.size === 0 && toRemove.size === 0 && toUpdate.size === 0) {\n        if (this._transaction) {\n          this._applyLayoutInfos();\n        }\n\n        return;\n      }\n    }\n\n    // Track views that should be removed. They are not removed from\n    // the DOM immediately, since we may reuse and need to re-insert\n    // them back into the DOM anyway.\n    let removed = new Set<ReusableView<T, V>>();\n\n    for (let key of toRemove.keys()) {\n      let view = this._visibleViews.get(key);\n      if (view) {\n        removed.add(view);\n        this._visibleViews.delete(key);\n\n        // If we are in the middle of a transaction, wait until the end\n        // of the animations to remove the views from the DOM. Also means\n        // we can't reuse those views immediately.\n        if (this._transaction) {\n          this._transaction.toRemove.set(key, view);\n        } else {\n          this.reuseView(view);\n        }\n      }\n    }\n\n    for (let key of toAdd.keys()) {\n      let layoutInfo = visibleLayoutInfos.get(key);\n      let view: ReusableView<T, V> | void;\n\n      // If we're in a transaction, and a layout change happens\n      // during the animations such that a view that was going\n      // to be removed is now not, we don't create a new view\n      // since the old one is still in the DOM, marked as toRemove.\n      if (this._transaction) {\n        // if transaction, get initial layout attributes for the animation\n        if (this._transaction.initialLayoutInfo.has(key)) {\n          layoutInfo = this._transaction.initialLayoutInfo.get(key);\n        }\n\n        view = this._transaction.toRemove.get(key);\n        if (view) {\n          this._transaction.toRemove.delete(key);\n          this._applyLayoutInfo(view, layoutInfo);\n        }\n      }\n\n      if (!view) {\n        // Create or reuse a view for this row\n        view = this.getReusableView(layoutInfo);\n\n        // Add the view to the DOM if needed\n        if (!removed.has(view)) {\n          this._children.add(view);\n        }\n      }\n\n      this._visibleViews.set(key, view);\n      removed.delete(view);\n    }\n\n    for (let key of toUpdate) {\n      let view = currentlyVisible.get(key) as ReusableView<T, V>;\n      this._renderedContent.delete(key);\n      this._renderView(view);\n    }\n\n    // Remove the remaining rows to delete from the DOM\n    if (!this._transaction) {\n      this.removeViews(removed);\n    }\n\n    this._correctItemOrder();\n    this._flushVisibleViews();\n\n    let hasLayoutUpdates = this._transaction && (toAdd.size > 0 || toRemove.size > 0 || this._hasLayoutUpdates());\n    if (hasLayoutUpdates) {\n      requestAnimationFrame(() => {\n        // If we're in a transaction, apply animations to visible views\n        // and \"to be removed\" views, which animate off screen.\n        if (this._transaction) {\n          requestAnimationFrame(() => this._applyLayoutInfos());\n        }\n      });\n    }\n\n    return hasLayoutUpdates;\n  }\n\n  afterRender() {\n    if (this._transactionQueue.length > 0) {\n      this._processTransactionQueue();\n    } else if (this._invalidationContext) {\n      this.relayoutNow();\n    }\n\n    if (this.shouldOverscan) {\n      this._overscanManager.collectMetrics();\n    }\n  }\n\n  private _flushVisibleViews() {\n    // CollectionVirtualizer deals with a flattened set of LayoutInfos, but they can represent hierarchy\n    // by referencing a parentKey. Just before rendering the visible views, we rebuild this hierarchy\n    // by creating a mapping of views by parent key and recursively calling the delegate's renderWrapper\n    // method to build the final tree.\n    let viewsByParentKey = new Map([[null, []]]);\n    for (let view of this._children) {\n      if (view.layoutInfo?.parentKey != null && !viewsByParentKey.has(view.layoutInfo.parentKey)) {\n        viewsByParentKey.set(view.layoutInfo.parentKey, []);\n      }\n\n      viewsByParentKey.get(view.layoutInfo?.parentKey)?.push(view);\n      if (!viewsByParentKey.has(view.layoutInfo?.key)) {\n        viewsByParentKey.set(view.layoutInfo?.key, []);\n      }\n    }\n\n    let buildTree = (parent: ReusableView<T, V>, views: ReusableView<T, V>[]): W[] => views.map(view => {\n      let children = viewsByParentKey.get(view.layoutInfo.key);\n      return this.delegate.renderWrapper(\n        parent,\n        view,\n        children,\n        (childViews) => buildTree(view, childViews)\n      );\n    });\n\n    let children = buildTree(null, viewsByParentKey.get(null));\n    this.delegate.setVisibleViews(children);\n  }\n\n  private _applyLayoutInfo(view: ReusableView<T, V>, layoutInfo: LayoutInfo) {\n    if (view.layoutInfo === layoutInfo) {\n      return false;\n    }\n\n    view.layoutInfo = layoutInfo;\n    return true;\n  }\n\n  private _applyLayoutInfos() {\n    let updated = false;\n\n    // Apply layout infos to visible views\n    for (let view of this._visibleViews.values()) {\n      let cur = view.layoutInfo;\n      if (cur?.key != null) {\n        let layoutInfo = this.layout.getLayoutInfo(cur.key);\n        if (this._applyLayoutInfo(view, layoutInfo)) {\n          updated = true;\n        }\n      }\n    }\n\n    // Apply final layout infos for views that will be removed\n    if (this._transaction) {\n      for (let view of this._transaction.toRemove.values()) {\n        let cur = view.layoutInfo;\n        if (cur?.key != null) {\n          let layoutInfo = this.layout.getLayoutInfo(cur.key);\n          if (this._applyLayoutInfo(view, layoutInfo)) {\n            updated = true;\n          }\n        }\n      }\n\n      for (let view of this._transaction.removed.values()) {\n        let cur = view.layoutInfo;\n        let layoutInfo = this._transaction.finalLayoutInfo.get(cur.key) || cur;\n        layoutInfo = this.layout.getFinalLayoutInfo(layoutInfo.copy());\n        if (this._applyLayoutInfo(view, layoutInfo)) {\n          updated = true;\n        }\n      }\n    }\n\n    if (updated) {\n      this._flushVisibleViews();\n    }\n  }\n\n  private _hasLayoutUpdates() {\n    if (!this._transaction) {\n      return false;\n    }\n\n    for (let view of this._visibleViews.values()) {\n      let cur = view.layoutInfo;\n      if (!cur) {\n        return true;\n      }\n\n      let layoutInfo = this.layout.getLayoutInfo(cur.key);\n      if (\n        // Uses equals rather than pointEquals so that width/height changes are taken into account\n        !cur.rect.equals(layoutInfo.rect) ||\n        cur.opacity !== layoutInfo.opacity ||\n        cur.transform !== layoutInfo.transform\n      ) {\n        return true;\n      }\n    }\n\n    return false;\n  }\n\n  reuseView(view: ReusableView<T, V>) {\n    view.prepareForReuse();\n    this._reusableViews[view.viewType].push(view);\n  }\n\n  removeViews(toRemove: Set<ReusableView<T, V>>) {\n    for (let view of toRemove) {\n      this._children.delete(view);\n    }\n  }\n\n  updateItemSize(key: Key, size: Size) {\n    // TODO: we should be able to invalidate a single index path\n    // @ts-ignore\n    if (!this.layout.updateItemSize) {\n      return;\n    }\n\n    // If the scroll position is currently animating, add the update\n    // to a queue to be processed after the animation is complete.\n    if (this._scrollAnimation) {\n      this._sizeUpdateQueue.set(key, size);\n      return;\n    }\n\n    // @ts-ignore\n    let changed = this.layout.updateItemSize(key, size);\n    if (changed) {\n      this.relayout();\n    }\n  }\n\n  startScrolling() {\n    this._isScrolling = true;\n  }\n\n  endScrolling() {\n    this._isScrolling = false;\n    this._correctItemOrder();\n    this._flushVisibleViews();\n  }\n\n  private _resetAnimatedContentOffset() {\n    // Reset the animated content offset of subviews. See comment in relayoutNow for details.\n    if (!this._animatedContentOffset.isOrigin()) {\n      this._animatedContentOffset = new Point(0, 0);\n      this._applyLayoutInfos();\n    }\n  }\n\n  /**\n   * Scrolls the item with the given key into view, optionally with an animation.\n   * @param key The key of the item to scroll into view.\n   * @param duration The duration of the scroll animation.\n   */\n  scrollToItem(key: Key, options?: ScrollToItemOptions) {\n    // key can be 0, so check if null or undefined\n    if (key == null) {\n      return;\n    }\n\n    let layoutInfo = this.layout.getLayoutInfo(key);\n    if (!layoutInfo) {\n      return;\n    }\n\n    let {\n      duration = 300,\n      shouldScrollX = true,\n      shouldScrollY = true,\n      offsetX = 0,\n      offsetY = 0\n    } = options;\n\n    let x = this.visibleRect.x;\n    let y = this.visibleRect.y;\n    let minX = layoutInfo.rect.x - offsetX;\n    let minY = layoutInfo.rect.y - offsetY;\n    let maxX = x + this.visibleRect.width;\n    let maxY = y + this.visibleRect.height;\n\n    if (shouldScrollX) {\n      if (minX <= x || maxX === 0) {\n        x = minX;\n      } else if (layoutInfo.rect.maxX > maxX) {\n        x += layoutInfo.rect.maxX - maxX;\n      }\n    }\n\n    if (shouldScrollY) {\n      if (minY <= y || maxY === 0) {\n        y = minY;\n      } else if (layoutInfo.rect.maxY > maxY) {\n        y += layoutInfo.rect.maxY - maxY;\n      }\n    }\n\n    return this.scrollTo(new Point(x, y), duration);\n  }\n\n  /**\n   * Performs an animated scroll to the given offset.\n   * @param offset - The offset to scroll to.\n   * @param duration The duration of the animation.\n   * @returns A promise that resolves when the animation is complete.\n   */\n  scrollTo(offset: Point, duration: number = 300): Promise<void> {\n    // Cancel the current scroll animation\n    if (this._scrollAnimation) {\n      this._scrollAnimation.cancel();\n      this._scrollAnimation = null;\n    }\n\n    // Set the content offset synchronously if the duration is zero\n    if (duration <= 0 || this.visibleRect.pointEquals(offset)) {\n      this._setContentOffset(offset);\n      return Promise.resolve();\n    }\n\n    this.startScrolling();\n\n    this._scrollAnimation = tween(this.visibleRect, offset, duration, easeOut, offset => {this._setContentOffset(offset);});\n    this._scrollAnimation.then(() => {\n      this._scrollAnimation = null;\n\n      // Process view size updates that occurred during the animation.\n      // Only views that are still visible will be actually updated.\n      for (let [key, size] of this._sizeUpdateQueue) {\n        this.updateItemSize(key, size);\n      }\n\n      this._sizeUpdateQueue.clear();\n      this.relayout();\n      this._processTransactionQueue();\n      this.endScrolling();\n    });\n\n    return this._scrollAnimation;\n  }\n\n  private _runTransaction(action: () => void, animated?: boolean) {\n    this._startTransaction();\n    if (this._nextTransaction) {\n      this._nextTransaction.actions.push(action);\n    }\n    this._endTransaction(animated);\n  }\n\n  private _startTransaction() {\n    if (!this._nextTransaction) {\n      this._nextTransaction = new Transaction;\n    }\n\n    this._nextTransaction.level++;\n  }\n\n  private _endTransaction(animated?: boolean) {\n    if (!this._nextTransaction) {\n      return false;\n    }\n\n    // Save whether the transaction should be animated.\n    if (animated != null) {\n      this._nextTransaction.animated = animated;\n    }\n\n    // If we haven't reached level 0, we are still in a\n    // nested transaction. Wait for the parent to end.\n    if (--this._nextTransaction.level > 0) {\n      return false;\n    }\n\n    // Do nothing for empty transactions\n    if (this._nextTransaction.actions.length === 0) {\n      this._nextTransaction = null;\n      return false;\n    }\n\n    // Default animations to true\n    if (this._nextTransaction.animated == null) {\n      this._nextTransaction.animated = true;\n    }\n\n    // Enqueue the transaction\n    this._transactionQueue.push(this._nextTransaction);\n    this._nextTransaction = null;\n\n    return true;\n  }\n\n  private _processTransactionQueue() {\n    // If the current transaction is animating, wait until the end\n    // to process the next transaction.\n    if (this._transaction || this._scrollAnimation) {\n      return;\n    }\n\n    let next = this._transactionQueue.shift();\n    if (next) {\n      this._performTransaction(next);\n    }\n  }\n\n  private _getContentRect(): Rect {\n    return new Rect(0, 0, this.contentSize.width, this.contentSize.height);\n  }\n\n  private _performTransaction(transaction: Transaction<T, V>) {\n    this._transaction = transaction;\n\n    this.relayoutNow({\n      transaction: transaction,\n      animated: transaction.animated,\n\n      beforeLayout: () => {\n        // Get the initial layout infos for all views before the updates\n        // so we can figure out which views to add and remove.\n        if (transaction.animated) {\n          transaction.initialMap = this._getLayoutInfoMap(this._getContentRect(), true);\n        }\n\n        // Apply the actions that occurred during this transaction\n        for (let action of transaction.actions) {\n          action();\n        }\n      },\n\n      afterLayout: () => {\n        // Get the final layout infos after the updates\n        if (transaction.animated) {\n          transaction.finalMap = this._getLayoutInfoMap(this._getContentRect());\n          this._setupTransactionAnimations(transaction);\n        } else {\n          this._transaction = null;\n        }\n      },\n\n      afterAnimation: () => {\n        // Remove and reuse views when animations are done\n        if (transaction.toRemove.size > 0 || transaction.removed.size > 0) {\n          for (let view of concatIterators(transaction.toRemove.values(), transaction.removed.values())) {\n            this._children.delete(view);\n            this.reuseView(view);\n          }\n        }\n\n        this._transaction = null;\n\n        // Ensure DOM order is correct for accessibility after animations are complete\n        this._correctItemOrder();\n        this._flushVisibleViews();\n\n        this._processTransactionQueue();\n      }\n    });\n  }\n\n  private _setupTransactionAnimations(transaction: Transaction<T, V>) {\n    let {initialMap, finalMap} = transaction;\n\n    // Store initial and final layout infos for animations\n    for (let [key, layoutInfo] of initialMap) {\n      if (finalMap.has(key)) {\n        // Store the initial layout info for use during animations.\n        transaction.initialLayoutInfo.set(key, layoutInfo);\n      } else {\n        // This view was removed. Store the layout info for use\n        // in Layout#getFinalLayoutInfo during animations.\n        transaction.finalLayoutInfo.set(layoutInfo.key, layoutInfo);\n      }\n    }\n\n    // Get initial layout infos for views that were added\n    for (let [key, layoutInfo] of finalMap) {\n      if (!initialMap.has(key)) {\n        let initialLayoutInfo = this.layout.getInitialLayoutInfo(layoutInfo.copy());\n        transaction.initialLayoutInfo.set(key, initialLayoutInfo);\n      }\n    }\n\n    // Figure out which views were removed.\n    for (let [key, view] of this._visibleViews) {\n      // If an item has a width of 0, there is no need to remove it from the _visibleViews.\n      // Removing an item with  width of 0 can cause a loop where the item gets added, removed,\n      // added, removed... etc in a loop.\n      if (!finalMap.has(key) && view.layoutInfo.rect.width > 0) {\n        transaction.removed.set(key, view);\n        this._visibleViews.delete(key);\n\n        // In case something weird happened, where we have a view but no\n        // initial layout info, use the one attached to the view.\n        if (view.layoutInfo) {\n          if (!transaction.finalLayoutInfo.has(view.layoutInfo.key)) {\n            transaction.finalLayoutInfo.set(view.layoutInfo.key, view.layoutInfo);\n          }\n        }\n      }\n    }\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}