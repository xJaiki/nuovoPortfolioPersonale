{"ast":null,"code":"import { alignCenter as $f62d864046160412$export$f4a51ff076cc9a09, constrainValue as $f62d864046160412$export$4f5203c0d889109e, isInvalid as $f62d864046160412$export$eac50920cf2fd59a, previousAvailableDate as $f62d864046160412$export$a1d3911297b952d7 } from \"./utils.mjs\";\nimport { useCalendarState as $131cf43a05231e1e$export$6d095e787d2b5e1f } from \"./useCalendarState.mjs\";\nimport { toCalendarDate as $d0gbl$toCalendarDate, maxDate as $d0gbl$maxDate, minDate as $d0gbl$minDate, isEqualDay as $d0gbl$isEqualDay, toCalendar as $d0gbl$toCalendar, GregorianCalendar as $d0gbl$GregorianCalendar } from \"@internationalized/date\";\nimport { useControlledState as $d0gbl$useControlledState } from \"@react-stately/utils\";\nimport { useState as $d0gbl$useState, useRef as $d0gbl$useRef, useMemo as $d0gbl$useMemo } from \"react\";\n\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nfunction $9a36b6ba2fb1a7c5$export$9a987164d97ecc90(props) {\n  let {\n    value: valueProp,\n    defaultValue: defaultValue,\n    onChange: onChange,\n    createCalendar: createCalendar,\n    locale: locale,\n    visibleDuration = {\n      months: 1\n    },\n    minValue: minValue,\n    maxValue: maxValue,\n    ...calendarProps\n  } = props;\n  let [value, setValue] = (0, $d0gbl$useControlledState)(valueProp, defaultValue || null, onChange);\n  let [anchorDate, setAnchorDateState] = (0, $d0gbl$useState)(null);\n  let alignment = 'center';\n  if (value && value.start && value.end) {\n    let start = (0, $f62d864046160412$export$f4a51ff076cc9a09)((0, $d0gbl$toCalendarDate)(value.start), visibleDuration, locale, minValue, maxValue);\n    let end = start.add(visibleDuration).subtract({\n      days: 1\n    });\n    if (value.end.compare(end) > 0) alignment = 'start';\n  }\n  // Available range must be stored in a ref so we have access to the updated version immediately in `isInvalid`.\n  let availableRangeRef = (0, $d0gbl$useRef)(null);\n  let [availableRange, setAvailableRange] = (0, $d0gbl$useState)(null);\n  let min = (0, $d0gbl$useMemo)(() => (0, $d0gbl$maxDate)(minValue, availableRange === null || availableRange === void 0 ? void 0 : availableRange.start), [minValue, availableRange]);\n  let max = (0, $d0gbl$useMemo)(() => (0, $d0gbl$minDate)(maxValue, availableRange === null || availableRange === void 0 ? void 0 : availableRange.end), [maxValue, availableRange]);\n  let calendar = (0, $131cf43a05231e1e$export$6d095e787d2b5e1f)({\n    ...calendarProps,\n    value: value && value.start,\n    createCalendar: createCalendar,\n    locale: locale,\n    visibleDuration: visibleDuration,\n    minValue: min,\n    maxValue: max,\n    selectionAlignment: alignment\n  });\n  let updateAvailableRange = date => {\n    if (date && props.isDateUnavailable && !props.allowsNonContiguousRanges) {\n      availableRangeRef.current = {\n        start: $9a36b6ba2fb1a7c5$var$nextUnavailableDate(date, calendar, -1),\n        end: $9a36b6ba2fb1a7c5$var$nextUnavailableDate(date, calendar, 1)\n      };\n      setAvailableRange(availableRangeRef.current);\n    } else {\n      availableRangeRef.current = null;\n      setAvailableRange(null);\n    }\n  };\n  // If the visible range changes, we need to update the available range.\n  let [lastVisibleRange, setLastVisibleRange] = (0, $d0gbl$useState)(calendar.visibleRange);\n  if (!(0, $d0gbl$isEqualDay)(calendar.visibleRange.start, lastVisibleRange.start) || !(0, $d0gbl$isEqualDay)(calendar.visibleRange.end, lastVisibleRange.end)) {\n    updateAvailableRange(anchorDate);\n    setLastVisibleRange(calendar.visibleRange);\n  }\n  let setAnchorDate = date => {\n    if (date) {\n      setAnchorDateState(date);\n      updateAvailableRange(date);\n    } else {\n      setAnchorDateState(null);\n      updateAvailableRange(null);\n    }\n  };\n  let highlightedRange = anchorDate ? $9a36b6ba2fb1a7c5$var$makeRange(anchorDate, calendar.focusedDate) : value && $9a36b6ba2fb1a7c5$var$makeRange(value.start, value.end);\n  let selectDate = date => {\n    if (props.isReadOnly) return;\n    date = (0, $f62d864046160412$export$4f5203c0d889109e)(date, min, max);\n    date = (0, $f62d864046160412$export$a1d3911297b952d7)(date, calendar.visibleRange.start, props.isDateUnavailable);\n    if (!date) return;\n    if (!anchorDate) setAnchorDate(date);else {\n      let range = $9a36b6ba2fb1a7c5$var$makeRange(anchorDate, date);\n      setValue({\n        start: $9a36b6ba2fb1a7c5$var$convertValue(range.start, value === null || value === void 0 ? void 0 : value.start),\n        end: $9a36b6ba2fb1a7c5$var$convertValue(range.end, value === null || value === void 0 ? void 0 : value.end)\n      });\n      setAnchorDate(null);\n    }\n  };\n  let [isDragging, setDragging] = (0, $d0gbl$useState)(false);\n  let {\n    isDateUnavailable: isDateUnavailable\n  } = props;\n  let isInvalidSelection = (0, $d0gbl$useMemo)(() => {\n    if (!value || anchorDate) return false;\n    if (isDateUnavailable && (isDateUnavailable(value.start) || isDateUnavailable(value.end))) return true;\n    return (0, $f62d864046160412$export$eac50920cf2fd59a)(value.start, minValue, maxValue) || (0, $f62d864046160412$export$eac50920cf2fd59a)(value.end, minValue, maxValue);\n  }, [isDateUnavailable, value, anchorDate, minValue, maxValue]);\n  let isValueInvalid = props.isInvalid || props.validationState === 'invalid' || isInvalidSelection;\n  let validationState = isValueInvalid ? 'invalid' : null;\n  return {\n    ...calendar,\n    value: value,\n    setValue: setValue,\n    anchorDate: anchorDate,\n    setAnchorDate: setAnchorDate,\n    highlightedRange: highlightedRange,\n    validationState: validationState,\n    isValueInvalid: isValueInvalid,\n    selectFocusedDate() {\n      selectDate(calendar.focusedDate);\n    },\n    selectDate: selectDate,\n    highlightDate(date) {\n      if (anchorDate) calendar.setFocusedDate(date);\n    },\n    isSelected(date) {\n      return highlightedRange && date.compare(highlightedRange.start) >= 0 && date.compare(highlightedRange.end) <= 0 && !calendar.isCellDisabled(date) && !calendar.isCellUnavailable(date);\n    },\n    isInvalid(date) {\n      var _availableRangeRef_current, _availableRangeRef_current1;\n      return calendar.isInvalid(date) || (0, $f62d864046160412$export$eac50920cf2fd59a)(date, (_availableRangeRef_current = availableRangeRef.current) === null || _availableRangeRef_current === void 0 ? void 0 : _availableRangeRef_current.start, (_availableRangeRef_current1 = availableRangeRef.current) === null || _availableRangeRef_current1 === void 0 ? void 0 : _availableRangeRef_current1.end);\n    },\n    isDragging: isDragging,\n    setDragging: setDragging\n  };\n}\nfunction $9a36b6ba2fb1a7c5$var$makeRange(start, end) {\n  if (!start || !end) return null;\n  if (end.compare(start) < 0) [start, end] = [end, start];\n  return {\n    start: (0, $d0gbl$toCalendarDate)(start),\n    end: (0, $d0gbl$toCalendarDate)(end)\n  };\n}\nfunction $9a36b6ba2fb1a7c5$var$convertValue(newValue, oldValue) {\n  // The display calendar should not have any effect on the emitted value.\n  // Emit dates in the same calendar as the original value, if any, otherwise gregorian.\n  newValue = (0, $d0gbl$toCalendar)(newValue, (oldValue === null || oldValue === void 0 ? void 0 : oldValue.calendar) || new (0, $d0gbl$GregorianCalendar)());\n  // Preserve time if the input value had one.\n  if (oldValue && 'hour' in oldValue) return oldValue.set(newValue);\n  return newValue;\n}\nfunction $9a36b6ba2fb1a7c5$var$nextUnavailableDate(anchorDate, state, dir) {\n  let nextDate = anchorDate.add({\n    days: dir\n  });\n  while ((dir < 0 ? nextDate.compare(state.visibleRange.start) >= 0 : nextDate.compare(state.visibleRange.end) <= 0) && !state.isCellUnavailable(nextDate)) nextDate = nextDate.add({\n    days: dir\n  });\n  if (state.isCellUnavailable(nextDate)) return nextDate.add({\n    days: -dir\n  });\n  return null;\n}\nexport { $9a36b6ba2fb1a7c5$export$9a987164d97ecc90 as useRangeCalendarState };","map":{"version":3,"names":["$9a36b6ba2fb1a7c5$export$9a987164d97ecc90","props","value","valueProp","defaultValue","onChange","createCalendar","locale","visibleDuration","months","minValue","maxValue","calendarProps","setValue","$d0gbl$useControlledState","anchorDate","setAnchorDateState","$d0gbl$useState","alignment","start","end","$f62d864046160412$export$f4a51ff076cc9a09","$d0gbl$toCalendarDate","add","subtract","days","compare","availableRangeRef","$d0gbl$useRef","availableRange","setAvailableRange","min","$d0gbl$useMemo","$d0gbl$maxDate","max","$d0gbl$minDate","calendar","$131cf43a05231e1e$export$6d095e787d2b5e1f","selectionAlignment","updateAvailableRange","date","isDateUnavailable","allowsNonContiguousRanges","current","$9a36b6ba2fb1a7c5$var$nextUnavailableDate","lastVisibleRange","setLastVisibleRange","visibleRange","$d0gbl$isEqualDay","setAnchorDate","highlightedRange","$9a36b6ba2fb1a7c5$var$makeRange","focusedDate","selectDate","isReadOnly","$f62d864046160412$export$4f5203c0d889109e","$f62d864046160412$export$a1d3911297b952d7","range","$9a36b6ba2fb1a7c5$var$convertValue","isDragging","setDragging","isInvalidSelection","$f62d864046160412$export$eac50920cf2fd59a","isValueInvalid","isInvalid","validationState","selectFocusedDate","highlightDate","setFocusedDate","isSelected","isCellDisabled","isCellUnavailable","_availableRangeRef_current","_availableRangeRef_current1","newValue","oldValue","$d0gbl$toCalendar","$d0gbl$GregorianCalendar","set","state","dir","nextDate"],"sources":["/Users/mario/Documents/pythonmongoreact/soldini/soldini-front/node_modules/@react-stately/calendar/dist/packages/@react-stately/calendar/src/useRangeCalendarState.ts"],"sourcesContent":["/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nimport {alignCenter, constrainValue, isInvalid, previousAvailableDate} from './utils';\nimport {Calendar, CalendarDate, DateDuration, GregorianCalendar, isEqualDay, maxDate, minDate, toCalendar, toCalendarDate} from '@internationalized/date';\nimport {CalendarState, RangeCalendarState} from './types';\nimport {DateRange, DateValue, RangeCalendarProps} from '@react-types/calendar';\nimport {RangeValue, ValidationState} from '@react-types/shared';\nimport {useCalendarState} from './useCalendarState';\nimport {useControlledState} from '@react-stately/utils';\nimport {useMemo, useRef, useState} from 'react';\n\nexport interface RangeCalendarStateOptions<T extends DateValue = DateValue> extends RangeCalendarProps<T> {\n  /** The locale to display and edit the value according to. */\n  locale: string,\n  /**\n   * A function that creates a [Calendar](../internationalized/date/Calendar.html)\n   * object for a given calendar identifier. Such a function may be imported from the\n   * `@internationalized/date` package, or manually implemented to include support for\n   * only certain calendars.\n   */\n  createCalendar: (name: string) => Calendar,\n  /**\n   * The amount of days that will be displayed at once. This affects how pagination works.\n   * @default {months: 1}\n   */\n  visibleDuration?: DateDuration\n}\n\n/**\n * Provides state management for a range calendar component.\n * A range calendar displays one or more date grids and allows users to select a contiguous range of dates.\n */\nexport function useRangeCalendarState<T extends DateValue = DateValue>(props: RangeCalendarStateOptions<T>): RangeCalendarState {\n  let {value: valueProp, defaultValue, onChange, createCalendar, locale, visibleDuration = {months: 1}, minValue, maxValue, ...calendarProps} = props;\n  let [value, setValue] = useControlledState<DateRange>(\n    valueProp,\n    defaultValue || null,\n    onChange\n  );\n\n  let [anchorDate, setAnchorDateState] = useState(null);\n  let alignment: 'center' | 'start' = 'center';\n  if (value && value.start && value.end) {\n    let start = alignCenter(toCalendarDate(value.start), visibleDuration, locale, minValue, maxValue);\n    let end = start.add(visibleDuration).subtract({days: 1});\n\n    if (value.end.compare(end) > 0) {\n      alignment = 'start';\n    }\n  }\n\n  // Available range must be stored in a ref so we have access to the updated version immediately in `isInvalid`.\n  let availableRangeRef = useRef<RangeValue<DateValue>>(null);\n  let [availableRange, setAvailableRange] = useState<RangeValue<DateValue>>(null);\n  let min = useMemo(() => maxDate(minValue, availableRange?.start), [minValue, availableRange]);\n  let max = useMemo(() => minDate(maxValue, availableRange?.end), [maxValue, availableRange]);\n\n  let calendar = useCalendarState({\n    ...calendarProps,\n    value: value && value.start,\n    createCalendar,\n    locale,\n    visibleDuration,\n    minValue: min,\n    maxValue: max,\n    selectionAlignment: alignment\n  });\n\n  let updateAvailableRange = (date) => {\n    if (date && props.isDateUnavailable && !props.allowsNonContiguousRanges) {\n      availableRangeRef.current = {\n        start: nextUnavailableDate(date, calendar, -1),\n        end: nextUnavailableDate(date, calendar, 1)\n      };\n      setAvailableRange(availableRangeRef.current);\n    } else {\n      availableRangeRef.current = null;\n      setAvailableRange(null);\n    }\n  };\n\n  // If the visible range changes, we need to update the available range.\n  let [lastVisibleRange, setLastVisibleRange] = useState(calendar.visibleRange);\n  if (!isEqualDay(calendar.visibleRange.start, lastVisibleRange.start) || !isEqualDay(calendar.visibleRange.end, lastVisibleRange.end)) {\n    updateAvailableRange(anchorDate);\n    setLastVisibleRange(calendar.visibleRange);\n  }\n\n  let setAnchorDate = (date: CalendarDate) => {\n    if (date) {\n      setAnchorDateState(date);\n      updateAvailableRange(date);\n    } else {\n      setAnchorDateState(null);\n      updateAvailableRange(null);\n    }\n  };\n\n  let highlightedRange = anchorDate ? makeRange(anchorDate, calendar.focusedDate) : value && makeRange(value.start, value.end);\n  let selectDate = (date: CalendarDate) => {\n    if (props.isReadOnly) {\n      return;\n    }\n\n    date = constrainValue(date, min, max);\n    date = previousAvailableDate(date, calendar.visibleRange.start, props.isDateUnavailable);\n    if (!date) {\n      return;\n    }\n\n    if (!anchorDate) {\n      setAnchorDate(date);\n    } else {\n      let range = makeRange(anchorDate, date);\n      setValue({\n        start: convertValue(range.start, value?.start),\n        end: convertValue(range.end, value?.end)\n      });\n      setAnchorDate(null);\n    }\n  };\n\n  let [isDragging, setDragging] = useState(false);\n\n  let {isDateUnavailable} = props;\n  let isInvalidSelection = useMemo(() => {\n    if (!value || anchorDate) {\n      return false;\n    }\n\n    if (isDateUnavailable && (isDateUnavailable(value.start) || isDateUnavailable(value.end))) {\n      return true;\n    }\n\n    return isInvalid(value.start, minValue, maxValue) || isInvalid(value.end, minValue, maxValue);\n  }, [isDateUnavailable, value, anchorDate, minValue, maxValue]);\n\n  let isValueInvalid = props.isInvalid || props.validationState === 'invalid' || isInvalidSelection;\n  let validationState: ValidationState = isValueInvalid ? 'invalid' : null;\n\n  return {\n    ...calendar,\n    value,\n    setValue,\n    anchorDate,\n    setAnchorDate,\n    highlightedRange,\n    validationState,\n    isValueInvalid,\n    selectFocusedDate() {\n      selectDate(calendar.focusedDate);\n    },\n    selectDate,\n    highlightDate(date) {\n      if (anchorDate) {\n        calendar.setFocusedDate(date);\n      }\n    },\n    isSelected(date) {\n      return highlightedRange && date.compare(highlightedRange.start) >= 0 && date.compare(highlightedRange.end) <= 0 && !calendar.isCellDisabled(date) && !calendar.isCellUnavailable(date);\n    },\n    isInvalid(date) {\n      return calendar.isInvalid(date) || isInvalid(date, availableRangeRef.current?.start, availableRangeRef.current?.end);\n    },\n    isDragging,\n    setDragging\n  };\n}\n\nfunction makeRange(start: DateValue, end: DateValue): RangeValue<CalendarDate> {\n  if (!start || !end) {\n    return null;\n  }\n\n  if (end.compare(start) < 0) {\n    [start, end] = [end, start];\n  }\n\n  return {start: toCalendarDate(start), end: toCalendarDate(end)};\n}\n\nfunction convertValue(newValue: CalendarDate, oldValue: DateValue) {\n  // The display calendar should not have any effect on the emitted value.\n  // Emit dates in the same calendar as the original value, if any, otherwise gregorian.\n  newValue = toCalendar(newValue, oldValue?.calendar || new GregorianCalendar());\n\n  // Preserve time if the input value had one.\n  if (oldValue && 'hour' in oldValue) {\n    return oldValue.set(newValue);\n  }\n\n  return newValue;\n}\n\nfunction nextUnavailableDate(anchorDate: CalendarDate, state: CalendarState, dir: number) {\n  let nextDate = anchorDate.add({days: dir});\n  while (\n    (dir < 0 ? nextDate.compare(state.visibleRange.start) >= 0 : nextDate.compare(state.visibleRange.end) <= 0) &&\n    !state.isCellUnavailable(nextDate)\n  ) {\n    nextDate = nextDate.add({days: dir});\n  }\n\n  if (state.isCellUnavailable(nextDate)) {\n    return nextDate.add({days: -dir});\n  }\n\n  return null;\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}