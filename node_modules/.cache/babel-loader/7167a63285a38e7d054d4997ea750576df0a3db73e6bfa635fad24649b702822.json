{"ast":null,"code":"import $3HATx$intlStringsmodulejs from \"./intlStrings.mjs\";\nimport { isSameDay as $3HATx$isSameDay, startOfMonth as $3HATx$startOfMonth, endOfMonth as $3HATx$endOfMonth } from \"@internationalized/date\";\nimport { useLocalizedStringFormatter as $3HATx$useLocalizedStringFormatter, useDateFormatter as $3HATx$useDateFormatter } from \"@react-aria/i18n\";\nimport { useMemo as $3HATx$useMemo } from \"react\";\nfunction $parcel$interopDefault(a) {\n  return a && a.__esModule ? a.default : a;\n}\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nconst $a074e1e2d0f0a665$export$653eddfc964b0f8a = new WeakMap();\nfunction $a074e1e2d0f0a665$export$134cbb7fb09a9522(date) {\n  return (date === null || date === void 0 ? void 0 : date.calendar.identifier) === 'gregory' && date.era === 'BC' ? 'short' : undefined;\n}\nfunction $a074e1e2d0f0a665$export$b6df97c887c38e1a(state) {\n  let stringFormatter = (0, $3HATx$useLocalizedStringFormatter)((0, $parcel$interopDefault($3HATx$intlStringsmodulejs)), '@react-aria/calendar');\n  let start, end;\n  if ('highlightedRange' in state) ({\n    start: start,\n    end: end\n  } = state.highlightedRange || {});else start = end = state.value;\n  let dateFormatter = (0, $3HATx$useDateFormatter)({\n    weekday: 'long',\n    month: 'long',\n    year: 'numeric',\n    day: 'numeric',\n    era: $a074e1e2d0f0a665$export$134cbb7fb09a9522(start) || $a074e1e2d0f0a665$export$134cbb7fb09a9522(end),\n    timeZone: state.timeZone\n  });\n  let anchorDate = 'anchorDate' in state ? state.anchorDate : null;\n  return (0, $3HATx$useMemo)(() => {\n    // No message if currently selecting a range, or there is nothing highlighted.\n    if (!anchorDate && start && end) {\n      // Use a single date message if the start and end dates are the same day,\n      // otherwise include both dates.\n      if ((0, $3HATx$isSameDay)(start, end)) {\n        let date = dateFormatter.format(start.toDate(state.timeZone));\n        return stringFormatter.format('selectedDateDescription', {\n          date: date\n        });\n      } else {\n        let dateRange = $a074e1e2d0f0a665$var$formatRange(dateFormatter, stringFormatter, start, end, state.timeZone);\n        return stringFormatter.format('selectedRangeDescription', {\n          dateRange: dateRange\n        });\n      }\n    }\n    return '';\n  }, [start, end, anchorDate, state.timeZone, stringFormatter, dateFormatter]);\n}\nfunction $a074e1e2d0f0a665$export$31afe65d91ef6e8(startDate, endDate, timeZone, isAria) {\n  let stringFormatter = (0, $3HATx$useLocalizedStringFormatter)((0, $parcel$interopDefault($3HATx$intlStringsmodulejs)), '@react-aria/calendar');\n  let era = $a074e1e2d0f0a665$export$134cbb7fb09a9522(startDate) || $a074e1e2d0f0a665$export$134cbb7fb09a9522(endDate);\n  let monthFormatter = (0, $3HATx$useDateFormatter)({\n    month: 'long',\n    year: 'numeric',\n    era: era,\n    calendar: startDate.calendar.identifier,\n    timeZone: timeZone\n  });\n  let dateFormatter = (0, $3HATx$useDateFormatter)({\n    month: 'long',\n    year: 'numeric',\n    day: 'numeric',\n    era: era,\n    calendar: startDate.calendar.identifier,\n    timeZone: timeZone\n  });\n  return (0, $3HATx$useMemo)(() => {\n    // Special case for month granularity. Format as a single month if only a\n    // single month is visible, otherwise format as a range of months.\n    if ((0, $3HATx$isSameDay)(startDate, (0, $3HATx$startOfMonth)(startDate))) {\n      if ((0, $3HATx$isSameDay)(endDate, (0, $3HATx$endOfMonth)(startDate))) return monthFormatter.format(startDate.toDate(timeZone));else if ((0, $3HATx$isSameDay)(endDate, (0, $3HATx$endOfMonth)(endDate))) return isAria ? $a074e1e2d0f0a665$var$formatRange(monthFormatter, stringFormatter, startDate, endDate, timeZone) : monthFormatter.formatRange(startDate.toDate(timeZone), endDate.toDate(timeZone));\n    }\n    return isAria ? $a074e1e2d0f0a665$var$formatRange(dateFormatter, stringFormatter, startDate, endDate, timeZone) : dateFormatter.formatRange(startDate.toDate(timeZone), endDate.toDate(timeZone));\n  }, [startDate, endDate, monthFormatter, dateFormatter, stringFormatter, timeZone, isAria]);\n}\nfunction $a074e1e2d0f0a665$var$formatRange(dateFormatter, stringFormatter, start, end, timeZone) {\n  let parts = dateFormatter.formatRangeToParts(start.toDate(timeZone), end.toDate(timeZone));\n  // Find the separator between the start and end date. This is determined\n  // by finding the last shared literal before the end range.\n  let separatorIndex = -1;\n  for (let i = 0; i < parts.length; i++) {\n    let part = parts[i];\n    if (part.source === 'shared' && part.type === 'literal') separatorIndex = i;else if (part.source === 'endRange') break;\n  }\n  // Now we can combine the parts into start and end strings.\n  let startValue = '';\n  let endValue = '';\n  for (let i = 0; i < parts.length; i++) {\n    if (i < separatorIndex) startValue += parts[i].value;else if (i > separatorIndex) endValue += parts[i].value;\n  }\n  return stringFormatter.format('dateRange', {\n    startDate: startValue,\n    endDate: endValue\n  });\n}\nexport { $a074e1e2d0f0a665$export$653eddfc964b0f8a as hookData, $a074e1e2d0f0a665$export$134cbb7fb09a9522 as getEraFormat, $a074e1e2d0f0a665$export$b6df97c887c38e1a as useSelectedDateDescription, $a074e1e2d0f0a665$export$31afe65d91ef6e8 as useVisibleRangeDescription };","map":{"version":3,"names":["$a074e1e2d0f0a665$export$653eddfc964b0f8a","WeakMap","$a074e1e2d0f0a665$export$134cbb7fb09a9522","date","calendar","identifier","era","undefined","$a074e1e2d0f0a665$export$b6df97c887c38e1a","state","stringFormatter","$3HATx$useLocalizedStringFormatter","$parcel$interopDefault","$3HATx$intlStringsmodulejs","start","end","highlightedRange","value","dateFormatter","$3HATx$useDateFormatter","weekday","month","year","day","timeZone","anchorDate","$3HATx$useMemo","$3HATx$isSameDay","format","toDate","dateRange","$a074e1e2d0f0a665$var$formatRange","$a074e1e2d0f0a665$export$31afe65d91ef6e8","startDate","endDate","isAria","monthFormatter","$3HATx$startOfMonth","$3HATx$endOfMonth","formatRange","parts","formatRangeToParts","separatorIndex","i","length","part","source","type","startValue","endValue"],"sources":["/Users/mario/Documents/pythonmongoreact/soldini/soldini-front/node_modules/@react-aria/calendar/dist/packages/@react-aria/calendar/src/utils.ts"],"sourcesContent":["/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nimport {CalendarDate, DateFormatter, endOfMonth, isSameDay, startOfMonth} from '@internationalized/date';\nimport {CalendarState, RangeCalendarState} from '@react-stately/calendar';\n// @ts-ignore\nimport intlMessages from '../intl/*.json';\nimport type {LocalizedStringFormatter} from '@internationalized/string';\nimport {useDateFormatter, useLocalizedStringFormatter} from '@react-aria/i18n';\nimport {useMemo} from 'react';\n\ninterface HookData {\n  ariaLabel: string,\n  ariaLabelledBy: string,\n  errorMessageId: string,\n  selectedDateDescription: string\n}\n\nexport const hookData = new WeakMap<CalendarState | RangeCalendarState, HookData>();\n\nexport function getEraFormat(date: CalendarDate): 'short' | undefined {\n  return date?.calendar.identifier === 'gregory' && date.era === 'BC' ? 'short' : undefined;\n}\n\nexport function useSelectedDateDescription(state: CalendarState | RangeCalendarState) {\n  let stringFormatter = useLocalizedStringFormatter(intlMessages, '@react-aria/calendar');\n\n  let start: CalendarDate, end: CalendarDate;\n  if ('highlightedRange' in state) {\n    ({start, end} = state.highlightedRange || {});\n  } else {\n    start = end = state.value;\n  }\n\n  let dateFormatter = useDateFormatter({\n    weekday: 'long',\n    month: 'long',\n    year: 'numeric',\n    day: 'numeric',\n    era: getEraFormat(start) || getEraFormat(end),\n    timeZone: state.timeZone\n  });\n\n  let anchorDate = 'anchorDate' in state ? state.anchorDate : null;\n  return useMemo(() => {\n    // No message if currently selecting a range, or there is nothing highlighted.\n    if (!anchorDate && start && end) {\n      // Use a single date message if the start and end dates are the same day,\n      // otherwise include both dates.\n      if (isSameDay(start, end)) {\n        let date = dateFormatter.format(start.toDate(state.timeZone));\n        return stringFormatter.format('selectedDateDescription', {date});\n      } else {\n        let dateRange = formatRange(dateFormatter, stringFormatter, start, end, state.timeZone);\n\n        return stringFormatter.format('selectedRangeDescription', {dateRange});\n      }\n    }\n    return '';\n  }, [start, end, anchorDate, state.timeZone, stringFormatter, dateFormatter]);\n}\n\nexport function useVisibleRangeDescription(startDate: CalendarDate, endDate: CalendarDate, timeZone: string, isAria: boolean) {\n  let stringFormatter = useLocalizedStringFormatter(intlMessages, '@react-aria/calendar');\n  let era: any = getEraFormat(startDate) || getEraFormat(endDate);\n  let monthFormatter = useDateFormatter({\n    month: 'long',\n    year: 'numeric',\n    era,\n    calendar: startDate.calendar.identifier,\n    timeZone\n  });\n\n  let dateFormatter = useDateFormatter({\n    month: 'long',\n    year: 'numeric',\n    day: 'numeric',\n    era,\n    calendar: startDate.calendar.identifier,\n    timeZone\n  });\n\n  return useMemo(() => {\n    // Special case for month granularity. Format as a single month if only a\n    // single month is visible, otherwise format as a range of months.\n    if (isSameDay(startDate, startOfMonth(startDate))) {\n      if (isSameDay(endDate, endOfMonth(startDate))) {\n        return monthFormatter.format(startDate.toDate(timeZone));\n      } else if (isSameDay(endDate, endOfMonth(endDate))) {\n        return isAria\n          ? formatRange(monthFormatter, stringFormatter, startDate, endDate, timeZone)\n          : monthFormatter.formatRange(startDate.toDate(timeZone), endDate.toDate(timeZone));\n      }\n    }\n\n    return isAria\n      ? formatRange(dateFormatter, stringFormatter, startDate, endDate, timeZone)\n      : dateFormatter.formatRange(startDate.toDate(timeZone), endDate.toDate(timeZone));\n  }, [startDate, endDate, monthFormatter, dateFormatter, stringFormatter, timeZone, isAria]);\n}\n\nfunction formatRange(dateFormatter: DateFormatter, stringFormatter: LocalizedStringFormatter, start: CalendarDate, end: CalendarDate, timeZone: string) {\n  let parts = dateFormatter.formatRangeToParts(start.toDate(timeZone), end.toDate(timeZone));\n\n  // Find the separator between the start and end date. This is determined\n  // by finding the last shared literal before the end range.\n  let separatorIndex = -1;\n  for (let i = 0; i < parts.length; i++) {\n    let part = parts[i];\n    if (part.source === 'shared' && part.type === 'literal') {\n      separatorIndex = i;\n    } else if (part.source === 'endRange') {\n      break;\n    }\n  }\n\n  // Now we can combine the parts into start and end strings.\n  let startValue = '';\n  let endValue = '';\n  for (let i = 0; i < parts.length; i++) {\n    if (i < separatorIndex) {\n      startValue += parts[i].value;\n    } else if (i > separatorIndex) {\n      endValue += parts[i].value;\n    }\n  }\n\n  return stringFormatter.format('dateRange', {startDate: startValue, endDate: endValue});\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}