{"ast":null,"code":"import { getColumnHeaderId as $2140fb2337097f2d$export$37cd4213f2ad742e } from \"./utils.mjs\";\nimport $d9Rqy$intlStringsmodulejs from \"./intlStrings.mjs\";\nimport { useRef as $d9Rqy$useRef, useCallback as $d9Rqy$useCallback, useEffect as $d9Rqy$useEffect } from \"react\";\nimport { focusSafely as $d9Rqy$focusSafely } from \"@react-aria/focus\";\nimport { useId as $d9Rqy$useId, useEffectEvent as $d9Rqy$useEffectEvent, useDescription as $d9Rqy$useDescription, mergeProps as $d9Rqy$mergeProps } from \"@react-aria/utils\";\nimport { useKeyboard as $d9Rqy$useKeyboard, useMove as $d9Rqy$useMove, useInteractionModality as $d9Rqy$useInteractionModality, usePress as $d9Rqy$usePress } from \"@react-aria/interactions\";\nimport { useLocalizedStringFormatter as $d9Rqy$useLocalizedStringFormatter, useLocale as $d9Rqy$useLocale } from \"@react-aria/i18n\";\nimport { useVisuallyHidden as $d9Rqy$useVisuallyHidden } from \"@react-aria/visually-hidden\";\nfunction $parcel$interopDefault(a) {\n  return a && a.__esModule ? a.default : a;\n}\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nfunction $e91ef4e5004e3774$export$52994e973806c219(props, state, ref) {\n  let {\n    column: item,\n    triggerRef: triggerRef,\n    isDisabled: isDisabled,\n    onResizeStart: onResizeStart,\n    onResize: onResize,\n    onResizeEnd: onResizeEnd,\n    'aria-label': ariaLabel\n  } = props;\n  const stringFormatter = (0, $d9Rqy$useLocalizedStringFormatter)((0, $parcel$interopDefault($d9Rqy$intlStringsmodulejs)), '@react-aria/table');\n  let id = (0, $d9Rqy$useId)();\n  let isResizing = state.resizingColumn === item.key;\n  let isResizingRef = (0, $d9Rqy$useRef)(isResizing);\n  let lastSize = (0, $d9Rqy$useRef)(null);\n  let wasFocusedOnResizeStart = (0, $d9Rqy$useRef)(false);\n  let editModeEnabled = state.tableState.isKeyboardNavigationDisabled;\n  let {\n    direction: direction\n  } = (0, $d9Rqy$useLocale)();\n  let {\n    keyboardProps: keyboardProps\n  } = (0, $d9Rqy$useKeyboard)({\n    onKeyDown: e => {\n      if (editModeEnabled) {\n        if (e.key === 'Escape' || e.key === 'Enter' || e.key === ' ' || e.key === 'Tab') {\n          e.preventDefault();\n          endResize(item);\n        }\n      } else {\n        // Continue propagation on keydown events so they still bubbles to useSelectableCollection and are handled there\n        e.continuePropagation();\n        if (e.key === 'Enter') startResize(item);\n      }\n    }\n  });\n  let startResize = (0, $d9Rqy$useEffectEvent)(item => {\n    if (!isResizingRef.current) {\n      lastSize.current = state.updateResizedColumns(item.key, state.getColumnWidth(item.key));\n      state.startResize(item.key);\n      state.tableState.setKeyboardNavigationDisabled(true);\n      onResizeStart === null || onResizeStart === void 0 ? void 0 : onResizeStart(lastSize.current);\n    }\n    isResizingRef.current = true;\n  });\n  let resize = (0, $d9Rqy$useEffectEvent)((item, newWidth) => {\n    let sizes = state.updateResizedColumns(item.key, newWidth);\n    onResize === null || onResize === void 0 ? void 0 : onResize(sizes);\n    lastSize.current = sizes;\n  });\n  let endResize = (0, $d9Rqy$useEffectEvent)(item => {\n    if (isResizingRef.current) {\n      if (lastSize.current == null) lastSize.current = state.updateResizedColumns(item.key, state.getColumnWidth(item.key));\n      state.endResize();\n      state.tableState.setKeyboardNavigationDisabled(false);\n      onResizeEnd === null || onResizeEnd === void 0 ? void 0 : onResizeEnd(lastSize.current);\n      isResizingRef.current = false;\n      if ((triggerRef === null || triggerRef === void 0 ? void 0 : triggerRef.current) && !wasFocusedOnResizeStart.current)\n        // switch focus back to the column header unless the resizer was already focused when resizing started.\n        (0, $d9Rqy$focusSafely)(triggerRef.current);\n    }\n    lastSize.current = null;\n  });\n  const columnResizeWidthRef = (0, $d9Rqy$useRef)(0);\n  const {\n    moveProps: moveProps\n  } = (0, $d9Rqy$useMove)({\n    onMoveStart() {\n      columnResizeWidthRef.current = state.getColumnWidth(item.key);\n      startResize(item);\n    },\n    onMove(e) {\n      let {\n        deltaX: deltaX,\n        deltaY: deltaY,\n        pointerType: pointerType\n      } = e;\n      if (direction === 'rtl') deltaX *= -1;\n      if (pointerType === 'keyboard') {\n        if (deltaY !== 0 && deltaX === 0) deltaX = deltaY * -1;\n        deltaX *= 10;\n      }\n      // if moving up/down only, no need to resize\n      if (deltaX !== 0) {\n        columnResizeWidthRef.current += deltaX;\n        resize(item, columnResizeWidthRef.current);\n      }\n    },\n    onMoveEnd(e) {\n      let {\n        pointerType: pointerType\n      } = e;\n      columnResizeWidthRef.current = 0;\n      if (pointerType === 'mouse' || pointerType === 'touch' && wasFocusedOnResizeStart.current) endResize(item);\n    }\n  });\n  let onKeyDown = (0, $d9Rqy$useCallback)(e => {\n    if (editModeEnabled) moveProps.onKeyDown(e);\n  }, [editModeEnabled, moveProps]);\n  let min = Math.floor(state.getColumnMinWidth(item.key));\n  let max = Math.floor(state.getColumnMaxWidth(item.key));\n  if (max === Infinity) max = Number.MAX_SAFE_INTEGER;\n  let value = Math.floor(state.getColumnWidth(item.key));\n  let modality = (0, $d9Rqy$useInteractionModality)();\n  if (modality === 'virtual' && typeof window !== 'undefined' && 'ontouchstart' in window) modality = 'touch';\n  let description = (triggerRef === null || triggerRef === void 0 ? void 0 : triggerRef.current) == null && (modality === 'keyboard' || modality === 'virtual') && !isResizing ? stringFormatter.format('resizerDescription') : undefined;\n  let descriptionProps = (0, $d9Rqy$useDescription)(description);\n  let ariaProps = {\n    'aria-label': ariaLabel,\n    'aria-orientation': 'horizontal',\n    'aria-labelledby': `${id} ${(0, $2140fb2337097f2d$export$37cd4213f2ad742e)(state.tableState, item.key)}`,\n    'aria-valuetext': stringFormatter.format('columnSize', {\n      value: value\n    }),\n    'type': 'range',\n    min: min,\n    max: max,\n    value: value,\n    ...descriptionProps\n  };\n  const focusInput = (0, $d9Rqy$useCallback)(() => {\n    if (ref.current) (0, $d9Rqy$focusSafely)(ref.current);\n  }, [ref]);\n  let resizingColumn = state.resizingColumn;\n  let prevResizingColumn = (0, $d9Rqy$useRef)(null);\n  (0, $d9Rqy$useEffect)(() => {\n    if (prevResizingColumn.current !== resizingColumn && resizingColumn != null && resizingColumn === item.key) {\n      wasFocusedOnResizeStart.current = document.activeElement === ref.current;\n      startResize(item);\n      // Delay focusing input until Android Chrome's delayed click after touchend happens: https://bugs.chromium.org/p/chromium/issues/detail?id=1150073\n      let timeout = setTimeout(() => focusInput(), 0);\n      // VoiceOver on iOS has problems focusing the input from a menu.\n      let VOTimeout = setTimeout(focusInput, 400);\n      return () => {\n        clearTimeout(timeout);\n        clearTimeout(VOTimeout);\n      };\n    }\n    prevResizingColumn.current = resizingColumn;\n  }, [resizingColumn, item, focusInput, ref, startResize]);\n  let onChange = e => {\n    let currentWidth = state.getColumnWidth(item.key);\n    let nextValue = parseFloat(e.target.value);\n    if (nextValue > currentWidth) nextValue = currentWidth + 10;else nextValue = currentWidth - 10;\n    resize(item, nextValue);\n  };\n  let {\n    pressProps: pressProps\n  } = (0, $d9Rqy$usePress)({\n    onPressStart: e => {\n      if (e.ctrlKey || e.altKey || e.metaKey || e.shiftKey || e.pointerType === 'keyboard') return;\n      if (e.pointerType === 'virtual' && state.resizingColumn != null) {\n        endResize(item);\n        return;\n      }\n      // Sometimes onPress won't trigger for quick taps on mobile so we want to focus the input so blurring away\n      // can cancel resize mode for us.\n      focusInput();\n      // If resizer is always visible, mobile screenreader user can access the visually hidden resizer directly and thus we don't need\n      // to handle a virtual click to start the resizer.\n      if (e.pointerType !== 'virtual') startResize(item);\n    },\n    onPress: e => {\n      if ((e.pointerType === 'touch' && wasFocusedOnResizeStart.current || e.pointerType === 'mouse') && state.resizingColumn != null) endResize(item);\n    }\n  });\n  let {\n    visuallyHiddenProps: visuallyHiddenProps\n  } = (0, $d9Rqy$useVisuallyHidden)();\n  return {\n    resizerProps: (0, $d9Rqy$mergeProps)(keyboardProps, {\n      ...moveProps,\n      onKeyDown: onKeyDown\n    }, pressProps, {\n      style: {\n        touchAction: 'none'\n      }\n    }),\n    inputProps: (0, $d9Rqy$mergeProps)(visuallyHiddenProps, {\n      id: id,\n      onBlur: () => {\n        endResize(item);\n      },\n      onChange: onChange,\n      disabled: isDisabled\n    }, ariaProps),\n    isResizing: isResizing\n  };\n}\nexport { $e91ef4e5004e3774$export$52994e973806c219 as useTableColumnResize };","map":{"version":3,"names":["$e91ef4e5004e3774$export$52994e973806c219","props","state","ref","column","item","triggerRef","isDisabled","onResizeStart","onResize","onResizeEnd","ariaLabel","stringFormatter","$d9Rqy$useLocalizedStringFormatter","$parcel$interopDefault","$d9Rqy$intlStringsmodulejs","id","$d9Rqy$useId","isResizing","resizingColumn","key","isResizingRef","$d9Rqy$useRef","lastSize","wasFocusedOnResizeStart","editModeEnabled","tableState","isKeyboardNavigationDisabled","direction","$d9Rqy$useLocale","keyboardProps","$d9Rqy$useKeyboard","onKeyDown","e","preventDefault","endResize","continuePropagation","startResize","$d9Rqy$useEffectEvent","current","updateResizedColumns","getColumnWidth","setKeyboardNavigationDisabled","resize","newWidth","sizes","$d9Rqy$focusSafely","columnResizeWidthRef","moveProps","$d9Rqy$useMove","onMoveStart","onMove","deltaX","deltaY","pointerType","onMoveEnd","$d9Rqy$useCallback","min","Math","floor","getColumnMinWidth","max","getColumnMaxWidth","Infinity","Number","MAX_SAFE_INTEGER","value","modality","$d9Rqy$useInteractionModality","window","description","format","undefined","descriptionProps","$d9Rqy$useDescription","ariaProps","$2140fb2337097f2d$export$37cd4213f2ad742e","focusInput","prevResizingColumn","$d9Rqy$useEffect","document","activeElement","timeout","setTimeout","VOTimeout","clearTimeout","onChange","currentWidth","nextValue","parseFloat","target","pressProps","$d9Rqy$usePress","onPressStart","ctrlKey","altKey","metaKey","shiftKey","onPress","visuallyHiddenProps","$d9Rqy$useVisuallyHidden","resizerProps","$d9Rqy$mergeProps","style","touchAction","inputProps","onBlur","disabled"],"sources":["/Users/mario/Documents/pythonmongoreact/soldini/soldini-front/node_modules/@react-aria/table/dist/packages/@react-aria/table/src/useTableColumnResize.ts"],"sourcesContent":["/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nimport {ChangeEvent, RefObject, useCallback, useEffect, useRef} from 'react';\nimport {ColumnSize} from '@react-types/table';\nimport {DOMAttributes, FocusableElement, Key} from '@react-types/shared';\nimport {focusSafely} from '@react-aria/focus';\nimport {getColumnHeaderId} from './utils';\nimport {GridNode} from '@react-types/grid';\n// @ts-ignore\nimport intlMessages from '../intl/*.json';\nimport {mergeProps, useDescription, useEffectEvent, useId} from '@react-aria/utils';\nimport {TableColumnResizeState} from '@react-stately/table';\nimport {useInteractionModality, useKeyboard, useMove, usePress} from '@react-aria/interactions';\nimport {useLocale, useLocalizedStringFormatter} from '@react-aria/i18n';\nimport {useVisuallyHidden} from '@react-aria/visually-hidden';\n\nexport interface TableColumnResizeAria {\n  /** Props for the visually hidden input element. */\n  inputProps: DOMAttributes,\n  /** Props for the resizer element. */\n  resizerProps: DOMAttributes,\n  /** Whether this column is currently being resized. */\n  isResizing: boolean\n}\n\nexport interface AriaTableColumnResizeProps<T> {\n  /** An object representing the [column header](https://www.w3.org/TR/wai-aria-1.1/#columnheader). Contains all the relevant information that makes up the column header. */\n  column: GridNode<T>,\n  /** Aria label for the hidden input. Gets read when resizing. */\n  'aria-label': string,\n  /**\n   * Ref to the trigger if resizing was started from a column header menu. If it's provided,\n   * focus will be returned there when resizing is done. If it isn't provided, it is assumed that the resizer is\n   * visible at all time and keyboard resizing is started via pressing Enter on the resizer and not on focus.\n   * */\n  triggerRef?: RefObject<FocusableElement>,\n  /** If resizing is disabled. */\n  isDisabled?: boolean,\n  /** Called when resizing starts. */\n  onResizeStart?: (widths: Map<Key, ColumnSize>) => void,\n  /** Called for every resize event that results in new column sizes. */\n  onResize?: (widths: Map<Key, ColumnSize>) => void,\n  /** Called when resizing ends. */\n  onResizeEnd?: (widths: Map<Key, ColumnSize>) => void\n}\n\n/**\n * Provides the behavior and accessibility implementation for a table column resizer element.\n * @param props - Props for the resizer.\n * @param state - State for the table's resizable columns, as returned by `useTableColumnResizeState`.\n * @param ref - The ref attached to the resizer's visually hidden input element.\n */\nexport function useTableColumnResize<T>(props: AriaTableColumnResizeProps<T>, state: TableColumnResizeState<T>, ref: RefObject<HTMLInputElement>): TableColumnResizeAria {\n  let {column: item, triggerRef, isDisabled, onResizeStart, onResize, onResizeEnd, 'aria-label': ariaLabel} = props;\n  const stringFormatter = useLocalizedStringFormatter(intlMessages, '@react-aria/table');\n  let id = useId();\n  let isResizing = state.resizingColumn === item.key;\n  let isResizingRef = useRef(isResizing);\n  let lastSize = useRef(null);\n  let wasFocusedOnResizeStart = useRef(false);\n  let editModeEnabled = state.tableState.isKeyboardNavigationDisabled;\n\n  let {direction} = useLocale();\n  let {keyboardProps} = useKeyboard({\n    onKeyDown: (e) => {\n      if (editModeEnabled) {\n        if (e.key === 'Escape' || e.key === 'Enter' || e.key === ' ' || e.key === 'Tab') {\n          e.preventDefault();\n          endResize(item);\n        }\n      } else {\n        // Continue propagation on keydown events so they still bubbles to useSelectableCollection and are handled there\n        e.continuePropagation();\n\n        if (e.key === 'Enter') {\n          startResize(item);\n        }\n      }\n    }\n  });\n\n  let startResize = useEffectEvent((item) => {\n    if (!isResizingRef.current) {\n      lastSize.current = state.updateResizedColumns(item.key, state.getColumnWidth(item.key));\n      state.startResize(item.key);\n      state.tableState.setKeyboardNavigationDisabled(true);\n      onResizeStart?.(lastSize.current);\n    }\n    isResizingRef.current = true;\n  });\n\n  let resize = useEffectEvent((item, newWidth) => {\n    let sizes = state.updateResizedColumns(item.key, newWidth);\n    onResize?.(sizes);\n    lastSize.current = sizes;\n  });\n\n  let endResize = useEffectEvent((item) => {\n    if (isResizingRef.current) {\n      if (lastSize.current == null) {\n        lastSize.current = state.updateResizedColumns(item.key, state.getColumnWidth(item.key));\n      }\n\n      state.endResize();\n      state.tableState.setKeyboardNavigationDisabled(false);\n      onResizeEnd?.(lastSize.current);\n      isResizingRef.current = false;\n\n      if (triggerRef?.current && !wasFocusedOnResizeStart.current) {\n        // switch focus back to the column header unless the resizer was already focused when resizing started.\n        focusSafely(triggerRef.current);\n      }\n    }\n    lastSize.current = null;\n  });\n\n  const columnResizeWidthRef = useRef<number>(0);\n  const {moveProps} = useMove({\n    onMoveStart() {\n      columnResizeWidthRef.current = state.getColumnWidth(item.key);\n      startResize(item);\n    },\n    onMove(e) {\n      let {deltaX, deltaY, pointerType} = e;\n      if (direction === 'rtl') {\n        deltaX *= -1;\n      }\n      if (pointerType === 'keyboard') {\n        if (deltaY !== 0 && deltaX === 0) {\n          deltaX = deltaY * -1;\n        }\n        deltaX *= 10;\n      }\n      // if moving up/down only, no need to resize\n      if (deltaX !== 0) {\n        columnResizeWidthRef.current += deltaX;\n        resize(item, columnResizeWidthRef.current);\n      }\n    },\n    onMoveEnd(e) {\n      let {pointerType} = e;\n      columnResizeWidthRef.current = 0;\n      if (pointerType === 'mouse' || (pointerType === 'touch' && wasFocusedOnResizeStart.current)) {\n        endResize(item);\n      }\n    }\n  });\n\n  let onKeyDown = useCallback((e) => {\n    if (editModeEnabled) {\n      moveProps.onKeyDown(e);\n    }\n  }, [editModeEnabled, moveProps]);\n\n\n  let min = Math.floor(state.getColumnMinWidth(item.key));\n  let max = Math.floor(state.getColumnMaxWidth(item.key));\n  if (max === Infinity) {\n    max = Number.MAX_SAFE_INTEGER;\n  }\n  let value = Math.floor(state.getColumnWidth(item.key));\n  let modality: string = useInteractionModality();\n  if (modality === 'virtual' &&  (typeof window !== 'undefined' && 'ontouchstart' in window)) {\n    modality = 'touch';\n  }\n  let description = triggerRef?.current == null && (modality === 'keyboard' || modality === 'virtual') && !isResizing ? stringFormatter.format('resizerDescription') : undefined;\n  let descriptionProps = useDescription(description);\n  let ariaProps = {\n    'aria-label': ariaLabel,\n    'aria-orientation': 'horizontal' as 'horizontal',\n    'aria-labelledby': `${id} ${getColumnHeaderId(state.tableState, item.key)}`,\n    'aria-valuetext': stringFormatter.format('columnSize', {value}),\n    'type': 'range',\n    min,\n    max,\n    value,\n    ...descriptionProps\n  };\n\n  const focusInput = useCallback(() => {\n    if (ref.current) {\n      focusSafely(ref.current);\n    }\n  }, [ref]);\n\n  let resizingColumn = state.resizingColumn;\n  let prevResizingColumn = useRef(null);\n  useEffect(() => {\n    if (prevResizingColumn.current !== resizingColumn && resizingColumn != null && resizingColumn === item.key) {\n      wasFocusedOnResizeStart.current = document.activeElement === ref.current;\n      startResize(item);\n      // Delay focusing input until Android Chrome's delayed click after touchend happens: https://bugs.chromium.org/p/chromium/issues/detail?id=1150073\n      let timeout = setTimeout(() => focusInput(), 0);\n      // VoiceOver on iOS has problems focusing the input from a menu.\n      let VOTimeout = setTimeout(focusInput, 400);\n      return () => {\n        clearTimeout(timeout);\n        clearTimeout(VOTimeout);\n      };\n    }\n    prevResizingColumn.current = resizingColumn;\n  }, [resizingColumn, item, focusInput, ref, startResize]);\n\n  let onChange = (e: ChangeEvent<HTMLInputElement>) => {\n    let currentWidth = state.getColumnWidth(item.key);\n    let nextValue = parseFloat(e.target.value);\n\n    if (nextValue > currentWidth) {\n      nextValue = currentWidth + 10;\n    } else {\n      nextValue = currentWidth - 10;\n    }\n    resize(item, nextValue);\n  };\n\n  let {pressProps} = usePress({\n    onPressStart: (e) => {\n      if (e.ctrlKey || e.altKey || e.metaKey || e.shiftKey || e.pointerType === 'keyboard') {\n        return;\n      }\n      if (e.pointerType === 'virtual' && state.resizingColumn != null) {\n        endResize(item);\n        return;\n      }\n\n      // Sometimes onPress won't trigger for quick taps on mobile so we want to focus the input so blurring away\n      // can cancel resize mode for us.\n      focusInput();\n\n      // If resizer is always visible, mobile screenreader user can access the visually hidden resizer directly and thus we don't need\n      // to handle a virtual click to start the resizer.\n      if (e.pointerType !== 'virtual') {\n        startResize(item);\n      }\n    },\n    onPress: (e) => {\n      if (((e.pointerType === 'touch' && wasFocusedOnResizeStart.current) || e.pointerType === 'mouse') && state.resizingColumn != null) {\n        endResize(item);\n      }\n    }\n  });\n  let {visuallyHiddenProps} = useVisuallyHidden();\n\n  return {\n    resizerProps: mergeProps(\n      keyboardProps,\n      {...moveProps, onKeyDown},\n      pressProps,\n      {style: {touchAction: 'none'}}\n    ),\n    inputProps: mergeProps(\n      visuallyHiddenProps,\n      {\n        id,\n        onBlur: () => {\n          endResize(item);\n        },\n        onChange,\n        disabled: isDisabled\n      },\n      ariaProps\n    ),\n    isResizing\n  };\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}