{"ast":null,"code":"import { getNthItem as $kbsd1$getNthItem, getChildNodes as $kbsd1$getChildNodes, getLastItem as $kbsd1$getLastItem, getFirstItem as $kbsd1$getFirstItem } from \"@react-stately/collections\";\nimport { Rect as $kbsd1$Rect } from \"@react-stately/virtualizer\";\n\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nclass $d1c300d9c497e402$export$de9feff04fda126e {\n  isCell(node) {\n    return node.type === 'cell';\n  }\n  isRow(node) {\n    return node.type === 'row' || node.type === 'item';\n  }\n  isDisabled(item) {\n    var _item_props;\n    return this.disabledBehavior === 'all' && (((_item_props = item.props) === null || _item_props === void 0 ? void 0 : _item_props.isDisabled) || this.disabledKeys.has(item.key));\n  }\n  findPreviousKey(fromKey, pred) {\n    let key = fromKey != null ? this.collection.getKeyBefore(fromKey) : this.collection.getLastKey();\n    while (key != null) {\n      let item = this.collection.getItem(key);\n      if (!this.isDisabled(item) && (!pred || pred(item))) return key;\n      key = this.collection.getKeyBefore(key);\n    }\n  }\n  findNextKey(fromKey, pred) {\n    let key = fromKey != null ? this.collection.getKeyAfter(fromKey) : this.collection.getFirstKey();\n    while (key != null) {\n      let item = this.collection.getItem(key);\n      if (!this.isDisabled(item) && (!pred || pred(item))) return key;\n      key = this.collection.getKeyAfter(key);\n    }\n  }\n  getKeyBelow(key) {\n    let startItem = this.collection.getItem(key);\n    if (!startItem) return;\n    // If focus was on a cell, start searching from the parent row\n    if (this.isCell(startItem)) key = startItem.parentKey;\n    // Find the next item\n    key = this.findNextKey(key);\n    if (key != null) {\n      // If focus was on a cell, focus the cell with the same index in the next row.\n      if (this.isCell(startItem)) {\n        let item = this.collection.getItem(key);\n        return (0, $kbsd1$getNthItem)((0, $kbsd1$getChildNodes)(item, this.collection), startItem.index).key;\n      }\n      // Otherwise, focus the next row\n      if (this.focusMode === 'row') return key;\n    }\n  }\n  getKeyAbove(key) {\n    let startItem = this.collection.getItem(key);\n    if (!startItem) return;\n    // If focus is on a cell, start searching from the parent row\n    if (this.isCell(startItem)) key = startItem.parentKey;\n    // Find the previous item\n    key = this.findPreviousKey(key);\n    if (key != null) {\n      // If focus was on a cell, focus the cell with the same index in the previous row.\n      if (this.isCell(startItem)) {\n        let item = this.collection.getItem(key);\n        return (0, $kbsd1$getNthItem)((0, $kbsd1$getChildNodes)(item, this.collection), startItem.index).key;\n      }\n      // Otherwise, focus the previous row\n      if (this.focusMode === 'row') return key;\n    }\n  }\n  getKeyRightOf(key) {\n    let item = this.collection.getItem(key);\n    if (!item) return;\n    // If focus is on a row, focus the first child cell.\n    if (this.isRow(item)) {\n      let children = (0, $kbsd1$getChildNodes)(item, this.collection);\n      return this.direction === 'rtl' ? (0, $kbsd1$getLastItem)(children).key : (0, $kbsd1$getFirstItem)(children).key;\n    }\n    // If focus is on a cell, focus the next cell if any,\n    // otherwise focus the parent row.\n    if (this.isCell(item)) {\n      let parent = this.collection.getItem(item.parentKey);\n      let children = (0, $kbsd1$getChildNodes)(parent, this.collection);\n      let next = this.direction === 'rtl' ? (0, $kbsd1$getNthItem)(children, item.index - 1) : (0, $kbsd1$getNthItem)(children, item.index + 1);\n      if (next) return next.key;\n      // focus row only if focusMode is set to row\n      if (this.focusMode === 'row') return item.parentKey;\n      return this.direction === 'rtl' ? this.getFirstKey(key) : this.getLastKey(key);\n    }\n  }\n  getKeyLeftOf(key) {\n    let item = this.collection.getItem(key);\n    if (!item) return;\n    // If focus is on a row, focus the last child cell.\n    if (this.isRow(item)) {\n      let children = (0, $kbsd1$getChildNodes)(item, this.collection);\n      return this.direction === 'rtl' ? (0, $kbsd1$getFirstItem)(children).key : (0, $kbsd1$getLastItem)(children).key;\n    }\n    // If focus is on a cell, focus the previous cell if any,\n    // otherwise focus the parent row.\n    if (this.isCell(item)) {\n      let parent = this.collection.getItem(item.parentKey);\n      let children = (0, $kbsd1$getChildNodes)(parent, this.collection);\n      let prev = this.direction === 'rtl' ? (0, $kbsd1$getNthItem)(children, item.index + 1) : (0, $kbsd1$getNthItem)(children, item.index - 1);\n      if (prev) return prev.key;\n      // focus row only if focusMode is set to row\n      if (this.focusMode === 'row') return item.parentKey;\n      return this.direction === 'rtl' ? this.getLastKey(key) : this.getFirstKey(key);\n    }\n  }\n  getFirstKey(key, global) {\n    let item;\n    if (key != null) {\n      item = this.collection.getItem(key);\n      if (!item) return;\n      // If global flag is not set, and a cell is currently focused,\n      // move focus to the first cell in the parent row.\n      if (this.isCell(item) && !global) {\n        let parent = this.collection.getItem(item.parentKey);\n        return (0, $kbsd1$getFirstItem)((0, $kbsd1$getChildNodes)(parent, this.collection)).key;\n      }\n    }\n    // Find the first row\n    key = this.findNextKey();\n    // If global flag is set (or if focus mode is cell), focus the first cell in the first row.\n    if (key != null && item && this.isCell(item) && global || this.focusMode === 'cell') {\n      let item = this.collection.getItem(key);\n      key = (0, $kbsd1$getFirstItem)((0, $kbsd1$getChildNodes)(item, this.collection)).key;\n    }\n    // Otherwise, focus the row itself.\n    return key;\n  }\n  getLastKey(key, global) {\n    let item;\n    if (key != null) {\n      item = this.collection.getItem(key);\n      if (!item) return;\n      // If global flag is not set, and a cell is currently focused,\n      // move focus to the last cell in the parent row.\n      if (this.isCell(item) && !global) {\n        let parent = this.collection.getItem(item.parentKey);\n        let children = (0, $kbsd1$getChildNodes)(parent, this.collection);\n        return (0, $kbsd1$getLastItem)(children).key;\n      }\n    }\n    // Find the last row\n    key = this.findPreviousKey();\n    // If global flag is set (or if focus mode is cell), focus the last cell in the last row.\n    if (key != null && item && this.isCell(item) && global || this.focusMode === 'cell') {\n      let item = this.collection.getItem(key);\n      let children = (0, $kbsd1$getChildNodes)(item, this.collection);\n      key = (0, $kbsd1$getLastItem)(children).key;\n    }\n    // Otherwise, focus the row itself.\n    return key;\n  }\n  getItem(key) {\n    return this.ref.current.querySelector(`[data-key=\"${CSS.escape(key.toString())}\"]`);\n  }\n  getItemRect(key) {\n    var _this_layout_getLayoutInfo;\n    if (this.layout) return (_this_layout_getLayoutInfo = this.layout.getLayoutInfo(key)) === null || _this_layout_getLayoutInfo === void 0 ? void 0 : _this_layout_getLayoutInfo.rect;\n    let item = this.getItem(key);\n    if (item) return new (0, $kbsd1$Rect)(item.offsetLeft, item.offsetTop, item.offsetWidth, item.offsetHeight);\n  }\n  getPageHeight() {\n    var _this_layout_virtualizer, _this_ref_current, _this_ref;\n    if (this.layout) return (_this_layout_virtualizer = this.layout.virtualizer) === null || _this_layout_virtualizer === void 0 ? void 0 : _this_layout_virtualizer.visibleRect.height;\n    return (_this_ref = this.ref) === null || _this_ref === void 0 ? void 0 : (_this_ref_current = _this_ref.current) === null || _this_ref_current === void 0 ? void 0 : _this_ref_current.offsetHeight;\n  }\n  getContentHeight() {\n    var _this_ref_current, _this_ref;\n    if (this.layout) return this.layout.getContentSize().height;\n    return (_this_ref = this.ref) === null || _this_ref === void 0 ? void 0 : (_this_ref_current = _this_ref.current) === null || _this_ref_current === void 0 ? void 0 : _this_ref_current.scrollHeight;\n  }\n  getKeyPageAbove(key) {\n    let itemRect = this.getItemRect(key);\n    if (!itemRect) return null;\n    let pageY = Math.max(0, itemRect.maxY - this.getPageHeight());\n    while (itemRect && itemRect.y > pageY) {\n      key = this.getKeyAbove(key);\n      itemRect = this.getItemRect(key);\n    }\n    return key;\n  }\n  getKeyPageBelow(key) {\n    let itemRect = this.getItemRect(key);\n    if (!itemRect) return null;\n    let pageHeight = this.getPageHeight();\n    let pageY = Math.min(this.getContentHeight(), itemRect.y + pageHeight);\n    while (itemRect && itemRect.maxY < pageY) {\n      let nextKey = this.getKeyBelow(key);\n      itemRect = this.getItemRect(nextKey);\n      // Guard against case where maxY of the last key is barely less than pageY due to rounding\n      // and thus it attempts to set key to null\n      if (nextKey != null) key = nextKey;\n    }\n    return key;\n  }\n  getKeyForSearch(search, fromKey) {\n    if (!this.collator) return null;\n    let collection = this.collection;\n    let key = fromKey !== null && fromKey !== void 0 ? fromKey : this.getFirstKey();\n    // If the starting key is a cell, search from its parent row.\n    let startItem = collection.getItem(key);\n    if (startItem.type === 'cell') key = startItem.parentKey;\n    let hasWrapped = false;\n    while (key != null) {\n      let item = collection.getItem(key);\n      // check row text value for match\n      if (item.textValue) {\n        let substring = item.textValue.slice(0, search.length);\n        if (this.collator.compare(substring, search) === 0) {\n          if (this.isRow(item) && this.focusMode === 'cell') return (0, $kbsd1$getFirstItem)((0, $kbsd1$getChildNodes)(item, this.collection)).key;\n          return item.key;\n        }\n      }\n      key = this.findNextKey(key);\n      // Wrap around when reaching the end of the collection\n      if (key == null && !hasWrapped) {\n        key = this.getFirstKey();\n        hasWrapped = true;\n      }\n    }\n    return null;\n  }\n  constructor(options) {\n    this.collection = options.collection;\n    this.disabledKeys = options.disabledKeys;\n    this.disabledBehavior = options.disabledBehavior || 'all';\n    this.ref = options.ref;\n    this.direction = options.direction;\n    this.collator = options.collator;\n    this.layout = options.layout;\n    this.focusMode = options.focusMode || 'row';\n  }\n}\nexport { $d1c300d9c497e402$export$de9feff04fda126e as GridKeyboardDelegate };","map":{"version":3,"names":["$d1c300d9c497e402$export$de9feff04fda126e","isCell","node","type","isRow","isDisabled","item","_item_props","disabledBehavior","props","disabledKeys","has","key","findPreviousKey","fromKey","pred","collection","getKeyBefore","getLastKey","getItem","findNextKey","getKeyAfter","getFirstKey","getKeyBelow","startItem","parentKey","$kbsd1$getNthItem","$kbsd1$getChildNodes","index","focusMode","getKeyAbove","getKeyRightOf","children","direction","$kbsd1$getLastItem","$kbsd1$getFirstItem","parent","next","getKeyLeftOf","prev","global","ref","current","querySelector","CSS","escape","toString","getItemRect","_this_layout_getLayoutInfo","layout","getLayoutInfo","rect","$kbsd1$Rect","offsetLeft","offsetTop","offsetWidth","offsetHeight","getPageHeight","_this_layout_virtualizer","_this_ref_current","_this_ref","virtualizer","visibleRect","height","getContentHeight","getContentSize","scrollHeight","getKeyPageAbove","itemRect","pageY","Math","max","maxY","y","getKeyPageBelow","pageHeight","min","nextKey","getKeyForSearch","search","collator","hasWrapped","textValue","substring","slice","length","compare","constructor","options"],"sources":["/Users/mario/Documents/Development/portfolio/node_modules/@react-aria/grid/dist/packages/@react-aria/grid/src/GridKeyboardDelegate.ts"],"sourcesContent":["/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nimport {Direction, DisabledBehavior, Key, KeyboardDelegate, Node} from '@react-types/shared';\nimport {getChildNodes, getFirstItem, getLastItem, getNthItem} from '@react-stately/collections';\nimport {GridCollection} from '@react-types/grid';\nimport {Layout, Rect} from '@react-stately/virtualizer';\nimport {RefObject} from 'react';\n\nexport interface GridKeyboardDelegateOptions<T, C> {\n  collection: C,\n  disabledKeys: Set<Key>,\n  disabledBehavior?: DisabledBehavior,\n  ref?: RefObject<HTMLElement>,\n  direction: Direction,\n  collator?: Intl.Collator,\n  layout?: Layout<Node<T>>,\n  focusMode?: 'row' | 'cell'\n}\n\nexport class GridKeyboardDelegate<T, C extends GridCollection<T>> implements KeyboardDelegate {\n  collection: C;\n  protected disabledKeys: Set<Key>;\n  protected disabledBehavior: DisabledBehavior;\n  protected ref: RefObject<HTMLElement>;\n  protected direction: Direction;\n  protected collator: Intl.Collator;\n  protected layout: Layout<Node<T>>;\n  protected focusMode;\n\n  constructor(options: GridKeyboardDelegateOptions<T, C>) {\n    this.collection = options.collection;\n    this.disabledKeys = options.disabledKeys;\n    this.disabledBehavior = options.disabledBehavior || 'all';\n    this.ref = options.ref;\n    this.direction = options.direction;\n    this.collator = options.collator;\n    this.layout = options.layout;\n    this.focusMode = options.focusMode || 'row';\n  }\n\n  protected isCell(node: Node<T>) {\n    return node.type === 'cell';\n  }\n\n  protected isRow(node: Node<T>) {\n    return node.type === 'row' || node.type === 'item';\n  }\n\n  private isDisabled(item: Node<unknown>) {\n    return this.disabledBehavior === 'all' && (item.props?.isDisabled || this.disabledKeys.has(item.key));\n  }\n\n  protected findPreviousKey(fromKey?: Key, pred?: (item: Node<T>) => boolean) {\n    let key = fromKey != null\n      ? this.collection.getKeyBefore(fromKey)\n      : this.collection.getLastKey();\n\n    while (key != null) {\n      let item = this.collection.getItem(key);\n      if (!this.isDisabled(item) && (!pred || pred(item))) {\n        return key;\n      }\n\n      key = this.collection.getKeyBefore(key);\n    }\n  }\n\n  protected findNextKey(fromKey?: Key, pred?: (item: Node<T>) => boolean) {\n    let key = fromKey != null\n      ? this.collection.getKeyAfter(fromKey)\n      : this.collection.getFirstKey();\n\n    while (key != null) {\n      let item = this.collection.getItem(key);\n      if (!this.isDisabled(item) && (!pred || pred(item))) {\n        return key;\n      }\n\n      key = this.collection.getKeyAfter(key);\n    }\n  }\n\n  getKeyBelow(key: Key) {\n    let startItem = this.collection.getItem(key);\n    if (!startItem) {\n      return;\n    }\n\n    // If focus was on a cell, start searching from the parent row\n    if (this.isCell(startItem)) {\n      key = startItem.parentKey;\n    }\n\n    // Find the next item\n    key = this.findNextKey(key);\n    if (key != null) {\n      // If focus was on a cell, focus the cell with the same index in the next row.\n      if (this.isCell(startItem)) {\n        let item = this.collection.getItem(key);\n        return getNthItem(getChildNodes(item, this.collection), startItem.index).key;\n      }\n\n      // Otherwise, focus the next row\n      if (this.focusMode === 'row') {\n        return key;\n      }\n    }\n  }\n\n  getKeyAbove(key: Key) {\n    let startItem = this.collection.getItem(key);\n    if (!startItem) {\n      return;\n    }\n\n    // If focus is on a cell, start searching from the parent row\n    if (this.isCell(startItem)) {\n      key = startItem.parentKey;\n    }\n\n    // Find the previous item\n    key = this.findPreviousKey(key);\n    if (key != null) {\n      // If focus was on a cell, focus the cell with the same index in the previous row.\n      if (this.isCell(startItem)) {\n        let item = this.collection.getItem(key);\n        return getNthItem(getChildNodes(item, this.collection), startItem.index).key;\n      }\n\n      // Otherwise, focus the previous row\n      if (this.focusMode === 'row') {\n        return key;\n      }\n    }\n  }\n\n  getKeyRightOf(key: Key) {\n    let item = this.collection.getItem(key);\n    if (!item) {\n      return;\n    }\n\n    // If focus is on a row, focus the first child cell.\n    if (this.isRow(item)) {\n      let children = getChildNodes(item, this.collection);\n      return this.direction === 'rtl'\n        ? getLastItem(children).key\n        : getFirstItem(children).key;\n    }\n\n    // If focus is on a cell, focus the next cell if any,\n    // otherwise focus the parent row.\n    if (this.isCell(item)) {\n      let parent = this.collection.getItem(item.parentKey);\n      let children = getChildNodes(parent, this.collection);\n      let next = this.direction === 'rtl'\n        ? getNthItem(children, item.index - 1)\n        : getNthItem(children, item.index + 1);\n\n      if (next) {\n        return next.key;\n      }\n\n      // focus row only if focusMode is set to row\n      if (this.focusMode === 'row') {\n        return item.parentKey;\n      }\n\n      return this.direction === 'rtl' ? this.getFirstKey(key) : this.getLastKey(key);\n    }\n  }\n\n  getKeyLeftOf(key: Key) {\n    let item = this.collection.getItem(key);\n    if (!item) {\n      return;\n    }\n\n    // If focus is on a row, focus the last child cell.\n    if (this.isRow(item)) {\n      let children = getChildNodes(item, this.collection);\n      return this.direction === 'rtl'\n        ? getFirstItem(children).key\n        : getLastItem(children).key;\n    }\n\n    // If focus is on a cell, focus the previous cell if any,\n    // otherwise focus the parent row.\n    if (this.isCell(item)) {\n      let parent = this.collection.getItem(item.parentKey);\n      let children = getChildNodes(parent, this.collection);\n      let prev = this.direction === 'rtl'\n        ? getNthItem(children, item.index + 1)\n        : getNthItem(children, item.index - 1);\n\n      if (prev) {\n        return prev.key;\n      }\n\n      // focus row only if focusMode is set to row\n      if (this.focusMode === 'row') {\n        return item.parentKey;\n      }\n\n      return this.direction === 'rtl' ? this.getLastKey(key) : this.getFirstKey(key);\n    }\n  }\n\n  getFirstKey(key?: Key, global?: boolean) {\n    let item: Node<T>;\n    if (key != null) {\n      item = this.collection.getItem(key);\n      if (!item) {\n        return;\n      }\n\n      // If global flag is not set, and a cell is currently focused,\n      // move focus to the first cell in the parent row.\n      if (this.isCell(item) && !global) {\n        let parent = this.collection.getItem(item.parentKey);\n        return getFirstItem(getChildNodes(parent, this.collection)).key;\n      }\n    }\n\n    // Find the first row\n    key = this.findNextKey();\n\n    // If global flag is set (or if focus mode is cell), focus the first cell in the first row.\n    if ((key != null && item && this.isCell(item) && global) || this.focusMode === 'cell') {\n      let item = this.collection.getItem(key);\n      key = getFirstItem(getChildNodes(item, this.collection)).key;\n    }\n\n    // Otherwise, focus the row itself.\n    return key;\n  }\n\n  getLastKey(key?: Key, global?: boolean) {\n    let item: Node<T>;\n    if (key != null) {\n      item = this.collection.getItem(key);\n      if (!item) {\n        return;\n      }\n\n      // If global flag is not set, and a cell is currently focused,\n      // move focus to the last cell in the parent row.\n      if (this.isCell(item) && !global) {\n        let parent = this.collection.getItem(item.parentKey);\n        let children = getChildNodes(parent, this.collection);\n        return getLastItem(children).key;\n      }\n    }\n\n    // Find the last row\n    key = this.findPreviousKey();\n\n    // If global flag is set (or if focus mode is cell), focus the last cell in the last row.\n    if ((key != null && item && this.isCell(item) && global) || this.focusMode === 'cell') {\n      let item = this.collection.getItem(key);\n      let children = getChildNodes(item, this.collection);\n      key = getLastItem(children).key;\n    }\n\n    // Otherwise, focus the row itself.\n    return key;\n  }\n\n  private getItem(key: Key): HTMLElement {\n    return this.ref.current.querySelector(`[data-key=\"${CSS.escape(key.toString())}\"]`);\n  }\n\n  private getItemRect(key: Key): Rect {\n    if (this.layout) {\n      return this.layout.getLayoutInfo(key)?.rect;\n    }\n\n    let item = this.getItem(key);\n    if (item) {\n      return new Rect(item.offsetLeft, item.offsetTop, item.offsetWidth, item.offsetHeight);\n    }\n  }\n\n  private getPageHeight(): number {\n    if (this.layout) {\n      return this.layout.virtualizer?.visibleRect.height;\n    }\n\n    return this.ref?.current?.offsetHeight;\n  }\n\n  private getContentHeight(): number {\n    if (this.layout) {\n      return this.layout.getContentSize().height;\n    }\n\n    return this.ref?.current?.scrollHeight;\n  }\n\n  getKeyPageAbove(key: Key) {\n    let itemRect = this.getItemRect(key);\n    if (!itemRect) {\n      return null;\n    }\n\n    let pageY = Math.max(0, itemRect.maxY - this.getPageHeight());\n\n    while (itemRect && itemRect.y > pageY) {\n      key = this.getKeyAbove(key);\n      itemRect = this.getItemRect(key);\n    }\n\n    return key;\n  }\n\n  getKeyPageBelow(key: Key) {\n    let itemRect = this.getItemRect(key);\n\n    if (!itemRect) {\n      return null;\n    }\n\n    let pageHeight = this.getPageHeight();\n    let pageY = Math.min(this.getContentHeight(), itemRect.y + pageHeight);\n\n    while (itemRect && itemRect.maxY < pageY) {\n      let nextKey = this.getKeyBelow(key);\n      itemRect = this.getItemRect(nextKey);\n\n      // Guard against case where maxY of the last key is barely less than pageY due to rounding\n      // and thus it attempts to set key to null\n      if (nextKey != null) {\n        key = nextKey;\n      }\n    }\n\n    return key;\n  }\n\n  getKeyForSearch(search: string, fromKey?: Key) {\n    if (!this.collator) {\n      return null;\n    }\n\n    let collection = this.collection;\n    let key = fromKey ?? this.getFirstKey();\n\n    // If the starting key is a cell, search from its parent row.\n    let startItem = collection.getItem(key);\n    if (startItem.type === 'cell') {\n      key = startItem.parentKey;\n    }\n\n    let hasWrapped = false;\n    while (key != null) {\n      let item = collection.getItem(key);\n\n      // check row text value for match\n      if (item.textValue) {\n        let substring = item.textValue.slice(0, search.length);\n        if (this.collator.compare(substring, search) === 0) {\n          if (this.isRow(item) && this.focusMode === 'cell') {\n            return getFirstItem(getChildNodes(item, this.collection)).key;\n          }\n\n          return item.key;\n        }\n      }\n\n      key = this.findNextKey(key);\n\n      // Wrap around when reaching the end of the collection\n      if (key == null && !hasWrapped) {\n        key = this.getFirstKey();\n        hasWrapped = true;\n      }\n    }\n\n    return null;\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}