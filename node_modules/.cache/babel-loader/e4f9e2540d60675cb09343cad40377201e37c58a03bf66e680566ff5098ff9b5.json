{"ast":null,"code":"import { getFirstItem as $eIXPM$getFirstItem, getChildNodes as $eIXPM$getChildNodes, getNthItem as $eIXPM$getNthItem } from \"@react-stately/collections\";\nimport { GridKeyboardDelegate as $eIXPM$GridKeyboardDelegate } from \"@react-aria/grid\";\n\n/*\n * Copyright 2022 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nclass $0ba3c81c7f1caedd$export$da43f8f5cb04028d extends (0, $eIXPM$GridKeyboardDelegate) {\n  isCell(node) {\n    return node.type === 'cell' || node.type === 'rowheader' || node.type === 'column';\n  }\n  getKeyBelow(key) {\n    let startItem = this.collection.getItem(key);\n    if (!startItem) return;\n    // If focus was on a column, then focus the first child column if any,\n    // or find the corresponding cell in the first row.\n    if (startItem.type === 'column') {\n      let child = (0, $eIXPM$getFirstItem)((0, $eIXPM$getChildNodes)(startItem, this.collection));\n      if (child) return child.key;\n      let firstKey = this.getFirstKey();\n      if (firstKey == null) return;\n      let firstItem = this.collection.getItem(firstKey);\n      return (0, $eIXPM$getNthItem)((0, $eIXPM$getChildNodes)(firstItem, this.collection), startItem.index).key;\n    }\n    return super.getKeyBelow(key);\n  }\n  getKeyAbove(key) {\n    let startItem = this.collection.getItem(key);\n    if (!startItem) return;\n    // If focus was on a column, focus the parent column if any\n    if (startItem.type === 'column') {\n      let parent = this.collection.getItem(startItem.parentKey);\n      if (parent && parent.type === 'column') return parent.key;\n      return;\n    }\n    // only return above row key if not header row\n    let superKey = super.getKeyAbove(key);\n    if (superKey != null && this.collection.getItem(superKey).type !== 'headerrow') return superKey;\n    // If no item was found, and focus was on a cell, then focus the\n    // corresponding column header.\n    if (this.isCell(startItem)) return this.collection.columns[startItem.index].key;\n    // If focus was on a row, then focus the first column header.\n    return this.collection.columns[0].key;\n  }\n  findNextColumnKey(column) {\n    // Search following columns\n    let key = this.findNextKey(column.key, item => item.type === 'column');\n    if (key != null) return key;\n    // Wrap around to the first column\n    let row = this.collection.headerRows[column.level];\n    for (let item of (0, $eIXPM$getChildNodes)(row, this.collection)) {\n      if (item.type === 'column') return item.key;\n    }\n  }\n  findPreviousColumnKey(column) {\n    // Search previous columns\n    let key = this.findPreviousKey(column.key, item => item.type === 'column');\n    if (key != null) return key;\n    // Wrap around to the last column\n    let row = this.collection.headerRows[column.level];\n    let childNodes = [...(0, $eIXPM$getChildNodes)(row, this.collection)];\n    for (let i = childNodes.length - 1; i >= 0; i--) {\n      let item = childNodes[i];\n      if (item.type === 'column') return item.key;\n    }\n  }\n  getKeyRightOf(key) {\n    let item = this.collection.getItem(key);\n    if (!item) return;\n    // If focus was on a column, then focus the next column\n    if (item.type === 'column') return this.direction === 'rtl' ? this.findPreviousColumnKey(item) : this.findNextColumnKey(item);\n    return super.getKeyRightOf(key);\n  }\n  getKeyLeftOf(key) {\n    let item = this.collection.getItem(key);\n    if (!item) return;\n    // If focus was on a column, then focus the previous column\n    if (item.type === 'column') return this.direction === 'rtl' ? this.findNextColumnKey(item) : this.findPreviousColumnKey(item);\n    return super.getKeyLeftOf(key);\n  }\n  getKeyForSearch(search, fromKey) {\n    if (!this.collator) return null;\n    let collection = this.collection;\n    let key = fromKey !== null && fromKey !== void 0 ? fromKey : this.getFirstKey();\n    if (key == null) return null;\n    // If the starting key is a cell, search from its parent row.\n    let startItem = collection.getItem(key);\n    if (startItem.type === 'cell') key = startItem.parentKey;\n    let hasWrapped = false;\n    while (key != null) {\n      let item = collection.getItem(key);\n      // Check each of the row header cells in this row for a match\n      for (let cell of (0, $eIXPM$getChildNodes)(item, this.collection)) {\n        let column = collection.columns[cell.index];\n        if (collection.rowHeaderColumnKeys.has(column.key) && cell.textValue) {\n          let substring = cell.textValue.slice(0, search.length);\n          if (this.collator.compare(substring, search) === 0) {\n            // If we started on a cell, end on the matching cell. Otherwise, end on the row.\n            let fromItem = fromKey != null ? collection.getItem(fromKey) : startItem;\n            return fromItem.type === 'cell' ? cell.key : item.key;\n          }\n        }\n      }\n      key = this.getKeyBelow(key);\n      // Wrap around when reaching the end of the collection\n      if (key == null && !hasWrapped) {\n        key = this.getFirstKey();\n        hasWrapped = true;\n      }\n    }\n    return null;\n  }\n}\nexport { $0ba3c81c7f1caedd$export$da43f8f5cb04028d as TableKeyboardDelegate };","map":{"version":3,"names":["$0ba3c81c7f1caedd$export$da43f8f5cb04028d","$eIXPM$GridKeyboardDelegate","isCell","node","type","getKeyBelow","key","startItem","collection","getItem","child","$eIXPM$getFirstItem","$eIXPM$getChildNodes","firstKey","getFirstKey","firstItem","$eIXPM$getNthItem","index","getKeyAbove","parent","parentKey","superKey","columns","findNextColumnKey","column","findNextKey","item","row","headerRows","level","findPreviousColumnKey","findPreviousKey","childNodes","i","length","getKeyRightOf","direction","getKeyLeftOf","getKeyForSearch","search","fromKey","collator","hasWrapped","cell","rowHeaderColumnKeys","has","textValue","substring","slice","compare","fromItem"],"sources":["/Users/mario/Documents/Development/portfolio/node_modules/@react-aria/table/dist/packages/@react-aria/table/src/TableKeyboardDelegate.ts"],"sourcesContent":["/*\n * Copyright 2022 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nimport {getChildNodes, getFirstItem, getNthItem} from '@react-stately/collections';\nimport {GridKeyboardDelegate} from '@react-aria/grid';\nimport {Key, Node} from '@react-types/shared';\nimport {TableCollection} from '@react-types/table';\n\nexport class TableKeyboardDelegate<T> extends GridKeyboardDelegate<T, TableCollection<T>> {\n\n  protected isCell(node: Node<T>) {\n    return node.type === 'cell' || node.type === 'rowheader' || node.type === 'column';\n  }\n\n  getKeyBelow(key: Key) {\n    let startItem = this.collection.getItem(key);\n    if (!startItem) {\n      return;\n    }\n\n    // If focus was on a column, then focus the first child column if any,\n    // or find the corresponding cell in the first row.\n    if (startItem.type === 'column') {\n      let child = getFirstItem(getChildNodes(startItem, this.collection));\n      if (child) {\n        return child.key;\n      }\n\n      let firstKey = this.getFirstKey();\n      if (firstKey == null) {\n        return;\n      }\n\n      let firstItem = this.collection.getItem(firstKey);\n      return getNthItem(getChildNodes(firstItem, this.collection), startItem.index).key;\n    }\n\n    return super.getKeyBelow(key);\n  }\n\n  getKeyAbove(key: Key) {\n    let startItem = this.collection.getItem(key);\n    if (!startItem) {\n      return;\n    }\n\n    // If focus was on a column, focus the parent column if any\n    if (startItem.type === 'column') {\n      let parent = this.collection.getItem(startItem.parentKey);\n      if (parent && parent.type === 'column') {\n        return parent.key;\n      }\n\n      return;\n    }\n\n    // only return above row key if not header row\n    let superKey = super.getKeyAbove(key);\n    if (superKey != null && this.collection.getItem(superKey).type !== 'headerrow') {\n      return superKey;\n    }\n\n    // If no item was found, and focus was on a cell, then focus the\n    // corresponding column header.\n    if (this.isCell(startItem)) {\n      return this.collection.columns[startItem.index].key;\n    }\n\n    // If focus was on a row, then focus the first column header.\n    return this.collection.columns[0].key;\n  }\n\n  private findNextColumnKey(column: Node<T>) {\n    // Search following columns\n    let key = this.findNextKey(column.key, item => item.type === 'column');\n    if (key != null) {\n      return key;\n    }\n\n    // Wrap around to the first column\n    let row = this.collection.headerRows[column.level];\n    for (let item of getChildNodes(row, this.collection)) {\n      if (item.type === 'column') {\n        return item.key;\n      }\n    }\n  }\n\n  private findPreviousColumnKey(column: Node<T>) {\n    // Search previous columns\n    let key = this.findPreviousKey(column.key, item => item.type === 'column');\n    if (key != null) {\n      return key;\n    }\n\n    // Wrap around to the last column\n    let row = this.collection.headerRows[column.level];\n    let childNodes = [...getChildNodes(row, this.collection)];\n    for (let i = childNodes.length - 1; i >= 0; i--) {\n      let item = childNodes[i];\n      if (item.type === 'column') {\n        return item.key;\n      }\n    }\n  }\n\n  getKeyRightOf(key: Key) {\n    let item = this.collection.getItem(key);\n    if (!item) {\n      return;\n    }\n\n    // If focus was on a column, then focus the next column\n    if (item.type === 'column') {\n      return this.direction === 'rtl'\n        ? this.findPreviousColumnKey(item)\n        : this.findNextColumnKey(item);\n    }\n\n    return super.getKeyRightOf(key);\n  }\n\n  getKeyLeftOf(key: Key) {\n    let item = this.collection.getItem(key);\n    if (!item) {\n      return;\n    }\n\n    // If focus was on a column, then focus the previous column\n    if (item.type === 'column') {\n      return this.direction === 'rtl'\n        ? this.findNextColumnKey(item)\n        : this.findPreviousColumnKey(item);\n    }\n\n    return super.getKeyLeftOf(key);\n  }\n\n  getKeyForSearch(search: string, fromKey?: Key) {\n    if (!this.collator) {\n      return null;\n    }\n\n    let collection = this.collection;\n    let key = fromKey ?? this.getFirstKey();\n    if (key == null) {\n      return null;\n    }\n\n    // If the starting key is a cell, search from its parent row.\n    let startItem = collection.getItem(key);\n    if (startItem.type === 'cell') {\n      key = startItem.parentKey;\n    }\n\n    let hasWrapped = false;\n    while (key != null) {\n      let item = collection.getItem(key);\n\n      // Check each of the row header cells in this row for a match\n      for (let cell of getChildNodes(item, this.collection)) {\n        let column = collection.columns[cell.index];\n        if (collection.rowHeaderColumnKeys.has(column.key) && cell.textValue) {\n          let substring = cell.textValue.slice(0, search.length);\n          if (this.collator.compare(substring, search) === 0) {\n            // If we started on a cell, end on the matching cell. Otherwise, end on the row.\n            let fromItem = fromKey != null ? collection.getItem(fromKey) : startItem;\n            return fromItem.type === 'cell'\n              ? cell.key\n              : item.key;\n          }\n        }\n      }\n\n      key = this.getKeyBelow(key);\n\n      // Wrap around when reaching the end of the collection\n      if (key == null && !hasWrapped) {\n        key = this.getFirstKey();\n        hasWrapped = true;\n      }\n    }\n\n    return null;\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}