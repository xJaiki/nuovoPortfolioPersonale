{"ast":null,"code":"import { hookData as $16f0b7bb276bc17e$export$653eddfc964b0f8a } from \"./useDateField.mjs\";\nimport { useDisplayNames as $3aeceb3a64eb8358$export$d42c60378c8168f8 } from \"./useDisplayNames.mjs\";\nimport { toCalendar as $4d1jn$toCalendar, CalendarDate as $4d1jn$CalendarDate } from \"@internationalized/date\";\nimport { isMac as $4d1jn$isMac, scrollIntoViewport as $4d1jn$scrollIntoViewport, getScrollParent as $4d1jn$getScrollParent, useEvent as $4d1jn$useEvent, useLayoutEffect as $4d1jn$useLayoutEffect, isIOS as $4d1jn$isIOS, useId as $4d1jn$useId, useLabels as $4d1jn$useLabels, mergeProps as $4d1jn$mergeProps } from \"@react-aria/utils\";\nimport { NumberParser as $4d1jn$NumberParser } from \"@internationalized/number\";\nimport $4d1jn$react, { useRef as $4d1jn$useRef, useMemo as $4d1jn$useMemo } from \"react\";\nimport { useLocale as $4d1jn$useLocale, useDateFormatter as $4d1jn$useDateFormatter, useFilter as $4d1jn$useFilter } from \"@react-aria/i18n\";\nimport { useSpinButton as $4d1jn$useSpinButton } from \"@react-aria/spinbutton\";\n\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nfunction $32489daedd52963e$export$1315d136e6f7581(segment, state, ref) {\n  let enteredKeys = (0, $4d1jn$useRef)('');\n  let {\n    locale: locale\n  } = (0, $4d1jn$useLocale)();\n  let displayNames = (0, $3aeceb3a64eb8358$export$d42c60378c8168f8)();\n  let {\n    ariaLabel: ariaLabel,\n    ariaLabelledBy: ariaLabelledBy,\n    ariaDescribedBy: ariaDescribedBy,\n    focusManager: focusManager\n  } = (0, $16f0b7bb276bc17e$export$653eddfc964b0f8a).get(state);\n  let textValue = segment.isPlaceholder ? '' : segment.text;\n  let options = (0, $4d1jn$useMemo)(() => state.dateFormatter.resolvedOptions(), [state.dateFormatter]);\n  let monthDateFormatter = (0, $4d1jn$useDateFormatter)({\n    month: 'long',\n    timeZone: options.timeZone\n  });\n  let hourDateFormatter = (0, $4d1jn$useDateFormatter)({\n    hour: 'numeric',\n    hour12: options.hour12,\n    timeZone: options.timeZone\n  });\n  if (segment.type === 'month' && !segment.isPlaceholder) {\n    let monthTextValue = monthDateFormatter.format(state.dateValue);\n    textValue = monthTextValue !== textValue ? `${textValue} \\u{2013} ${monthTextValue}` : monthTextValue;\n  } else if (segment.type === 'hour' && !segment.isPlaceholder) textValue = hourDateFormatter.format(state.dateValue);\n  let {\n    spinButtonProps: spinButtonProps\n  } = (0, $4d1jn$useSpinButton)({\n    // The ARIA spec says aria-valuenow is optional if there's no value, but aXe seems to require it.\n    // This doesn't seem to have any negative effects with real AT since we also use aria-valuetext.\n    // https://github.com/dequelabs/axe-core/issues/3505\n    value: segment.value,\n    textValue: textValue,\n    minValue: segment.minValue,\n    maxValue: segment.maxValue,\n    isDisabled: state.isDisabled,\n    isReadOnly: state.isReadOnly || !segment.isEditable,\n    isRequired: state.isRequired,\n    onIncrement: () => {\n      enteredKeys.current = '';\n      state.increment(segment.type);\n    },\n    onDecrement: () => {\n      enteredKeys.current = '';\n      state.decrement(segment.type);\n    },\n    onIncrementPage: () => {\n      enteredKeys.current = '';\n      state.incrementPage(segment.type);\n    },\n    onDecrementPage: () => {\n      enteredKeys.current = '';\n      state.decrementPage(segment.type);\n    },\n    onIncrementToMax: () => {\n      enteredKeys.current = '';\n      state.setSegment(segment.type, segment.maxValue);\n    },\n    onDecrementToMin: () => {\n      enteredKeys.current = '';\n      state.setSegment(segment.type, segment.minValue);\n    }\n  });\n  let parser = (0, $4d1jn$useMemo)(() => new (0, $4d1jn$NumberParser)(locale, {\n    maximumFractionDigits: 0\n  }), [locale]);\n  let backspace = () => {\n    if (segment.text === segment.placeholder) focusManager.focusPrevious();\n    if (parser.isValidPartialNumber(segment.text) && !state.isReadOnly && !segment.isPlaceholder) {\n      let newValue = segment.text.slice(0, -1);\n      let parsed = parser.parse(newValue);\n      newValue = parsed === 0 ? '' : newValue;\n      if (newValue.length === 0 || parsed === 0) state.clearSegment(segment.type);else state.setSegment(segment.type, parsed);\n      enteredKeys.current = newValue;\n    } else if (segment.type === 'dayPeriod') state.clearSegment(segment.type);\n  };\n  let onKeyDown = e => {\n    // Firefox does not fire selectstart for Ctrl/Cmd + A\n    // https://bugzilla.mozilla.org/show_bug.cgi?id=1742153\n    if (e.key === 'a' && ((0, $4d1jn$isMac)() ? e.metaKey : e.ctrlKey)) e.preventDefault();\n    if (e.ctrlKey || e.metaKey || e.shiftKey || e.altKey) return;\n    switch (e.key) {\n      case 'Backspace':\n      case 'Delete':\n        // Safari on iOS does not fire beforeinput for the backspace key because the cursor is at the start.\n        e.preventDefault();\n        e.stopPropagation();\n        backspace();\n        break;\n    }\n  };\n  // Safari dayPeriod option doesn't work...\n  let {\n    startsWith: startsWith\n  } = (0, $4d1jn$useFilter)({\n    sensitivity: 'base'\n  });\n  let amPmFormatter = (0, $4d1jn$useDateFormatter)({\n    hour: 'numeric',\n    hour12: true\n  });\n  let am = (0, $4d1jn$useMemo)(() => {\n    let date = new Date();\n    date.setHours(0);\n    return amPmFormatter.formatToParts(date).find(part => part.type === 'dayPeriod').value;\n  }, [amPmFormatter]);\n  let pm = (0, $4d1jn$useMemo)(() => {\n    let date = new Date();\n    date.setHours(12);\n    return amPmFormatter.formatToParts(date).find(part => part.type === 'dayPeriod').value;\n  }, [amPmFormatter]);\n  // Get a list of formatted era names so users can type the first character to choose one.\n  let eraFormatter = (0, $4d1jn$useDateFormatter)({\n    year: 'numeric',\n    era: 'narrow',\n    timeZone: 'UTC'\n  });\n  let eras = (0, $4d1jn$useMemo)(() => {\n    if (segment.type !== 'era') return [];\n    let date = (0, $4d1jn$toCalendar)(new (0, $4d1jn$CalendarDate)(1, 1, 1), state.calendar);\n    let eras = state.calendar.getEras().map(era => {\n      let eraDate = date.set({\n        year: 1,\n        month: 1,\n        day: 1,\n        era: era\n      }).toDate('UTC');\n      let parts = eraFormatter.formatToParts(eraDate);\n      let formatted = parts.find(p => p.type === 'era').value;\n      return {\n        era: era,\n        formatted: formatted\n      };\n    });\n    // Remove the common prefix from formatted values. This is so that in calendars with eras like\n    // ERA0 and ERA1 (e.g. Ethiopic), users can press \"0\" and \"1\" to select an era. In other cases,\n    // the first letter is used.\n    let prefixLength = $32489daedd52963e$var$commonPrefixLength(eras.map(era => era.formatted));\n    if (prefixLength) for (let era of eras) era.formatted = era.formatted.slice(prefixLength);\n    return eras;\n  }, [eraFormatter, state.calendar, segment.type]);\n  let onInput = key => {\n    if (state.isDisabled || state.isReadOnly) return;\n    let newValue = enteredKeys.current + key;\n    switch (segment.type) {\n      case 'dayPeriod':\n        if (startsWith(am, key)) state.setSegment('dayPeriod', 0);else if (startsWith(pm, key)) state.setSegment('dayPeriod', 12);else break;\n        focusManager.focusNext();\n        break;\n      case 'era':\n        {\n          let matched = eras.find(e => startsWith(e.formatted, key));\n          if (matched) {\n            state.setSegment('era', matched.era);\n            focusManager.focusNext();\n          }\n          break;\n        }\n      case 'day':\n      case 'hour':\n      case 'minute':\n      case 'second':\n      case 'month':\n      case 'year':\n        {\n          if (!parser.isValidPartialNumber(newValue)) return;\n          let numberValue = parser.parse(newValue);\n          let segmentValue = numberValue;\n          let allowsZero = segment.minValue === 0;\n          if (segment.type === 'hour' && state.dateFormatter.resolvedOptions().hour12) {\n            switch (state.dateFormatter.resolvedOptions().hourCycle) {\n              case 'h11':\n                if (numberValue > 11) segmentValue = parser.parse(key);\n                break;\n              case 'h12':\n                allowsZero = false;\n                if (numberValue > 12) segmentValue = parser.parse(key);\n                break;\n            }\n            if (segment.value >= 12 && numberValue > 1) numberValue += 12;\n          } else if (numberValue > segment.maxValue) segmentValue = parser.parse(key);\n          if (isNaN(numberValue)) return;\n          let shouldSetValue = segmentValue !== 0 || allowsZero;\n          if (shouldSetValue) state.setSegment(segment.type, segmentValue);\n          if (Number(numberValue + '0') > segment.maxValue || newValue.length >= String(segment.maxValue).length) {\n            enteredKeys.current = '';\n            if (shouldSetValue) focusManager.focusNext();\n          } else enteredKeys.current = newValue;\n          break;\n        }\n    }\n  };\n  let onFocus = () => {\n    enteredKeys.current = '';\n    (0, $4d1jn$scrollIntoViewport)(ref.current, {\n      containingElement: (0, $4d1jn$getScrollParent)(ref.current)\n    });\n    // Collapse selection to start or Chrome won't fire input events.\n    let selection = window.getSelection();\n    selection.collapse(ref.current);\n  };\n  let compositionRef = (0, $4d1jn$useRef)('');\n  // @ts-ignore - TODO: possibly old TS version? doesn't fail in my editor...\n  (0, $4d1jn$useEvent)(ref, 'beforeinput', e => {\n    e.preventDefault();\n    switch (e.inputType) {\n      case 'deleteContentBackward':\n      case 'deleteContentForward':\n        if (parser.isValidPartialNumber(segment.text) && !state.isReadOnly) backspace();\n        break;\n      case 'insertCompositionText':\n        // insertCompositionText cannot be canceled.\n        // Record the current state of the element so we can restore it in the `input` event below.\n        compositionRef.current = ref.current.textContent;\n        // Safari gets stuck in a composition state unless we also assign to the value here.\n        // eslint-disable-next-line no-self-assign\n        ref.current.textContent = ref.current.textContent;\n        break;\n      default:\n        if (e.data != null) onInput(e.data);\n        break;\n    }\n  });\n  (0, $4d1jn$useEvent)(ref, 'input', e => {\n    let {\n      inputType: inputType,\n      data: data\n    } = e;\n    switch (inputType) {\n      case 'insertCompositionText':\n        // Reset the DOM to how it was in the beforeinput event.\n        ref.current.textContent = compositionRef.current;\n        // Android sometimes fires key presses of letters as composition events. Need to handle am/pm keys here too.\n        // Can also happen e.g. with Pinyin keyboard on iOS.\n        if (startsWith(am, data) || startsWith(pm, data)) onInput(data);\n        break;\n    }\n  });\n  (0, $4d1jn$useLayoutEffect)(() => {\n    let element = ref.current;\n    return () => {\n      // If the focused segment is removed, focus the previous one, or the next one if there was no previous one.\n      if (document.activeElement === element) {\n        let prev = focusManager.focusPrevious();\n        if (!prev) focusManager.focusNext();\n      }\n    };\n  }, [ref, focusManager]);\n  // spinbuttons cannot be focused with VoiceOver on iOS.\n  let touchPropOverrides = (0, $4d1jn$isIOS)() || segment.type === 'timeZoneName' ? {\n    role: 'textbox',\n    'aria-valuemax': null,\n    'aria-valuemin': null,\n    'aria-valuetext': null,\n    'aria-valuenow': null\n  } : {};\n  // Only apply aria-describedby to the first segment, unless the field is invalid. This avoids it being\n  // read every time the user navigates to a new segment.\n  let firstSegment = (0, $4d1jn$useMemo)(() => state.segments.find(s => s.isEditable), [state.segments]);\n  if (segment !== firstSegment && !state.isInvalid) ariaDescribedBy = undefined;\n  let id = (0, $4d1jn$useId)();\n  let isEditable = !state.isDisabled && !state.isReadOnly && segment.isEditable;\n  // Prepend the label passed from the field to each segment name.\n  // This is needed because VoiceOver on iOS does not announce groups.\n  let name = segment.type === 'literal' ? '' : displayNames.of(segment.type);\n  let labelProps = (0, $4d1jn$useLabels)({\n    'aria-label': `${name}${ariaLabel ? `, ${ariaLabel}` : ''}${ariaLabelledBy ? ', ' : ''}`,\n    'aria-labelledby': ariaLabelledBy\n  });\n  // Literal segments should not be visible to screen readers. We don't really need any of the above,\n  // but the rules of hooks mean hooks cannot be conditional so we have to put this condition here.\n  if (segment.type === 'literal') return {\n    segmentProps: {\n      'aria-hidden': true\n    }\n  };\n  return {\n    segmentProps: (0, $4d1jn$mergeProps)(spinButtonProps, labelProps, {\n      id: id,\n      ...touchPropOverrides,\n      'aria-invalid': state.isInvalid ? 'true' : undefined,\n      'aria-describedby': ariaDescribedBy,\n      'aria-readonly': state.isReadOnly || !segment.isEditable ? 'true' : undefined,\n      'data-placeholder': segment.isPlaceholder || undefined,\n      contentEditable: isEditable,\n      suppressContentEditableWarning: isEditable,\n      spellCheck: isEditable ? 'false' : undefined,\n      autoCapitalize: isEditable ? 'off' : undefined,\n      autoCorrect: isEditable ? 'off' : undefined,\n      // Capitalization was changed in React 17...\n      [parseInt((0, $4d1jn$react).version, 10) >= 17 ? 'enterKeyHint' : 'enterkeyhint']: isEditable ? 'next' : undefined,\n      inputMode: state.isDisabled || segment.type === 'dayPeriod' || segment.type === 'era' || !isEditable ? undefined : 'numeric',\n      tabIndex: state.isDisabled ? undefined : 0,\n      onKeyDown: onKeyDown,\n      onFocus: onFocus,\n      style: {\n        caretColor: 'transparent'\n      },\n      // Prevent pointer events from reaching useDatePickerGroup, and allow native browser behavior to focus the segment.\n      onPointerDown(e) {\n        e.stopPropagation();\n      },\n      onMouseDown(e) {\n        e.stopPropagation();\n      }\n    })\n  };\n}\nfunction $32489daedd52963e$var$commonPrefixLength(strings) {\n  // Sort the strings, and compare the characters in the first and last to find the common prefix.\n  strings.sort();\n  let first = strings[0];\n  let last = strings[strings.length - 1];\n  for (let i = 0; i < first.length; i++) {\n    if (first[i] !== last[i]) return i;\n  }\n  return 0;\n}\nexport { $32489daedd52963e$export$1315d136e6f7581 as useDateSegment };","map":{"version":3,"names":["$32489daedd52963e$export$1315d136e6f7581","segment","state","ref","enteredKeys","$4d1jn$useRef","locale","$4d1jn$useLocale","displayNames","$3aeceb3a64eb8358$export$d42c60378c8168f8","ariaLabel","ariaLabelledBy","ariaDescribedBy","focusManager","$16f0b7bb276bc17e$export$653eddfc964b0f8a","get","textValue","isPlaceholder","text","options","$4d1jn$useMemo","dateFormatter","resolvedOptions","monthDateFormatter","$4d1jn$useDateFormatter","month","timeZone","hourDateFormatter","hour","hour12","type","monthTextValue","format","dateValue","spinButtonProps","$4d1jn$useSpinButton","value","minValue","maxValue","isDisabled","isReadOnly","isEditable","isRequired","onIncrement","current","increment","onDecrement","decrement","onIncrementPage","incrementPage","onDecrementPage","decrementPage","onIncrementToMax","setSegment","onDecrementToMin","parser","$4d1jn$NumberParser","maximumFractionDigits","backspace","placeholder","focusPrevious","isValidPartialNumber","newValue","slice","parsed","parse","length","clearSegment","onKeyDown","e","key","$4d1jn$isMac","metaKey","ctrlKey","preventDefault","shiftKey","altKey","stopPropagation","startsWith","$4d1jn$useFilter","sensitivity","amPmFormatter","am","date","Date","setHours","formatToParts","find","part","pm","eraFormatter","year","era","eras","$4d1jn$toCalendar","$4d1jn$CalendarDate","calendar","getEras","map","eraDate","set","day","toDate","parts","formatted","p","prefixLength","$32489daedd52963e$var$commonPrefixLength","onInput","focusNext","matched","numberValue","segmentValue","allowsZero","hourCycle","isNaN","shouldSetValue","Number","String","onFocus","$4d1jn$scrollIntoViewport","containingElement","$4d1jn$getScrollParent","selection","window","getSelection","collapse","compositionRef","$4d1jn$useEvent","inputType","textContent","data","$4d1jn$useLayoutEffect","element","document","activeElement","prev","touchPropOverrides","$4d1jn$isIOS","role","firstSegment","segments","s","isInvalid","undefined","id","$4d1jn$useId","name","of","labelProps","$4d1jn$useLabels","segmentProps","$4d1jn$mergeProps","contentEditable","suppressContentEditableWarning","spellCheck","autoCapitalize","autoCorrect","parseInt","$4d1jn$react","version","inputMode","tabIndex","style","caretColor","onPointerDown","onMouseDown","strings","sort","first","last","i"],"sources":["/Users/mario/Documents/pythonmongoreact/soldini/soldini-front/node_modules/@react-aria/datepicker/dist/packages/@react-aria/datepicker/src/useDateSegment.ts"],"sourcesContent":["/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nimport {CalendarDate, toCalendar} from '@internationalized/date';\nimport {DateFieldState, DateSegment} from '@react-stately/datepicker';\nimport {DOMAttributes} from '@react-types/shared';\nimport {getScrollParent, isIOS, isMac, mergeProps, scrollIntoViewport, useEvent, useId, useLabels, useLayoutEffect} from '@react-aria/utils';\nimport {hookData} from './useDateField';\nimport {NumberParser} from '@internationalized/number';\nimport React, {RefObject, useMemo, useRef} from 'react';\nimport {useDateFormatter, useFilter, useLocale} from '@react-aria/i18n';\nimport {useDisplayNames} from './useDisplayNames';\nimport {useSpinButton} from '@react-aria/spinbutton';\n\nexport interface DateSegmentAria {\n  /** Props for the segment element. */\n  segmentProps: DOMAttributes\n}\n\n/**\n * Provides the behavior and accessibility implementation for a segment in a date field.\n * A date segment displays an individual unit of a date and time, and allows users to edit\n * the value by typing or using the arrow keys to increment and decrement.\n */\nexport function useDateSegment(segment: DateSegment, state: DateFieldState, ref: RefObject<HTMLElement>): DateSegmentAria {\n  let enteredKeys = useRef('');\n  let {locale} = useLocale();\n  let displayNames = useDisplayNames();\n  let {ariaLabel, ariaLabelledBy, ariaDescribedBy, focusManager} = hookData.get(state);\n\n  let textValue = segment.isPlaceholder ? '' : segment.text;\n  let options = useMemo(() => state.dateFormatter.resolvedOptions(), [state.dateFormatter]);\n  let monthDateFormatter = useDateFormatter({month: 'long', timeZone: options.timeZone});\n  let hourDateFormatter = useDateFormatter({\n    hour: 'numeric',\n    hour12: options.hour12,\n    timeZone: options.timeZone\n  });\n\n  if (segment.type === 'month' && !segment.isPlaceholder) {\n    let monthTextValue = monthDateFormatter.format(state.dateValue);\n    textValue = monthTextValue !== textValue ? `${textValue} â€“ ${monthTextValue}` : monthTextValue;\n  } else if (segment.type === 'hour' && !segment.isPlaceholder) {\n    textValue = hourDateFormatter.format(state.dateValue);\n  }\n\n  let {spinButtonProps} = useSpinButton({\n    // The ARIA spec says aria-valuenow is optional if there's no value, but aXe seems to require it.\n    // This doesn't seem to have any negative effects with real AT since we also use aria-valuetext.\n    // https://github.com/dequelabs/axe-core/issues/3505\n    value: segment.value,\n    textValue,\n    minValue: segment.minValue,\n    maxValue: segment.maxValue,\n    isDisabled: state.isDisabled,\n    isReadOnly: state.isReadOnly || !segment.isEditable,\n    isRequired: state.isRequired,\n    onIncrement: () => {\n      enteredKeys.current = '';\n      state.increment(segment.type);\n    },\n    onDecrement: () => {\n      enteredKeys.current = '';\n      state.decrement(segment.type);\n    },\n    onIncrementPage: () => {\n      enteredKeys.current = '';\n      state.incrementPage(segment.type);\n    },\n    onDecrementPage: () => {\n      enteredKeys.current = '';\n      state.decrementPage(segment.type);\n    },\n    onIncrementToMax: () => {\n      enteredKeys.current = '';\n      state.setSegment(segment.type, segment.maxValue);\n    },\n    onDecrementToMin: () => {\n      enteredKeys.current = '';\n      state.setSegment(segment.type, segment.minValue);\n    }\n  });\n\n  let parser = useMemo(() => new NumberParser(locale, {maximumFractionDigits: 0}), [locale]);\n\n  let backspace = () => {\n    if (segment.text === segment.placeholder) {\n      focusManager.focusPrevious();\n    }\n    if (parser.isValidPartialNumber(segment.text) && !state.isReadOnly && !segment.isPlaceholder) {\n      let newValue = segment.text.slice(0, -1);\n      let parsed = parser.parse(newValue);\n      newValue = parsed === 0 ? '' : newValue;\n      if (newValue.length === 0 || parsed === 0) {\n        state.clearSegment(segment.type);\n      } else {\n        state.setSegment(segment.type, parsed);\n      }\n      enteredKeys.current = newValue;\n    } else if (segment.type === 'dayPeriod') {\n      state.clearSegment(segment.type);\n    }\n  };\n\n  let onKeyDown = (e) => {\n    // Firefox does not fire selectstart for Ctrl/Cmd + A\n    // https://bugzilla.mozilla.org/show_bug.cgi?id=1742153\n    if (e.key === 'a' && (isMac() ? e.metaKey : e.ctrlKey)) {\n      e.preventDefault();\n    }\n\n    if (e.ctrlKey || e.metaKey || e.shiftKey || e.altKey) {\n      return;\n    }\n\n    switch (e.key) {\n      case 'Backspace':\n      case 'Delete': {\n        // Safari on iOS does not fire beforeinput for the backspace key because the cursor is at the start.\n        e.preventDefault();\n        e.stopPropagation();\n        backspace();\n        break;\n      }\n    }\n  };\n\n  // Safari dayPeriod option doesn't work...\n  let {startsWith} = useFilter({sensitivity: 'base'});\n  let amPmFormatter = useDateFormatter({hour: 'numeric', hour12: true});\n  let am = useMemo(() => {\n    let date = new Date();\n    date.setHours(0);\n    return amPmFormatter.formatToParts(date).find(part => part.type === 'dayPeriod').value;\n  }, [amPmFormatter]);\n\n  let pm = useMemo(() => {\n    let date = new Date();\n    date.setHours(12);\n    return amPmFormatter.formatToParts(date).find(part => part.type === 'dayPeriod').value;\n  }, [amPmFormatter]);\n\n  // Get a list of formatted era names so users can type the first character to choose one.\n  let eraFormatter = useDateFormatter({year: 'numeric', era: 'narrow', timeZone: 'UTC'});\n  let eras = useMemo(() => {\n    if (segment.type !== 'era') {\n      return [];\n    }\n\n    let date = toCalendar(new CalendarDate(1, 1, 1), state.calendar);\n    let eras = state.calendar.getEras().map(era => {\n      let eraDate = date.set({year: 1, month: 1, day: 1, era}).toDate('UTC');\n      let parts = eraFormatter.formatToParts(eraDate);\n      let formatted = parts.find(p => p.type === 'era').value;\n      return {era, formatted};\n    });\n\n    // Remove the common prefix from formatted values. This is so that in calendars with eras like\n    // ERA0 and ERA1 (e.g. Ethiopic), users can press \"0\" and \"1\" to select an era. In other cases,\n    // the first letter is used.\n    let prefixLength = commonPrefixLength(eras.map(era => era.formatted));\n    if (prefixLength) {\n      for (let era of eras) {\n        era.formatted = era.formatted.slice(prefixLength);\n      }\n    }\n\n    return eras;\n  }, [eraFormatter, state.calendar, segment.type]);\n\n  let onInput = (key: string) => {\n    if (state.isDisabled || state.isReadOnly) {\n      return;\n    }\n\n    let newValue = enteredKeys.current + key;\n\n    switch (segment.type) {\n      case 'dayPeriod':\n        if (startsWith(am, key)) {\n          state.setSegment('dayPeriod', 0);\n        } else if (startsWith(pm, key)) {\n          state.setSegment('dayPeriod', 12);\n        } else {\n          break;\n        }\n        focusManager.focusNext();\n        break;\n      case 'era': {\n        let matched = eras.find(e => startsWith(e.formatted, key));\n        if (matched) {\n          state.setSegment('era', matched.era);\n          focusManager.focusNext();\n        }\n        break;\n      }\n      case 'day':\n      case 'hour':\n      case 'minute':\n      case 'second':\n      case 'month':\n      case 'year': {\n        if (!parser.isValidPartialNumber(newValue)) {\n          return;\n        }\n\n        let numberValue = parser.parse(newValue);\n        let segmentValue = numberValue;\n        let allowsZero = segment.minValue === 0;\n        if (segment.type === 'hour' && state.dateFormatter.resolvedOptions().hour12) {\n          switch (state.dateFormatter.resolvedOptions().hourCycle) {\n            case 'h11':\n              if (numberValue > 11) {\n                segmentValue = parser.parse(key);\n              }\n              break;\n            case 'h12':\n              allowsZero = false;\n              if (numberValue > 12) {\n                segmentValue = parser.parse(key);\n              }\n              break;\n          }\n\n          if (segment.value >= 12 && numberValue > 1) {\n            numberValue += 12;\n          }\n        } else if (numberValue > segment.maxValue) {\n          segmentValue = parser.parse(key);\n        }\n\n        if (isNaN(numberValue)) {\n          return;\n        }\n\n        let shouldSetValue = segmentValue !== 0 || allowsZero;\n        if (shouldSetValue) {\n          state.setSegment(segment.type, segmentValue);\n        }\n\n        if (Number(numberValue + '0') > segment.maxValue || newValue.length >= String(segment.maxValue).length) {\n          enteredKeys.current = '';\n          if (shouldSetValue) {\n            focusManager.focusNext();\n          }\n        } else {\n          enteredKeys.current = newValue;\n        }\n        break;\n      }\n    }\n  };\n\n  let onFocus = () => {\n    enteredKeys.current = '';\n    scrollIntoViewport(ref.current, {containingElement: getScrollParent(ref.current)});\n\n    // Collapse selection to start or Chrome won't fire input events.\n    let selection = window.getSelection();\n    selection.collapse(ref.current);\n  };\n\n  let compositionRef = useRef('');\n  // @ts-ignore - TODO: possibly old TS version? doesn't fail in my editor...\n  useEvent(ref, 'beforeinput', e => {\n    e.preventDefault();\n\n    switch (e.inputType) {\n      case 'deleteContentBackward':\n      case 'deleteContentForward':\n        if (parser.isValidPartialNumber(segment.text) && !state.isReadOnly) {\n          backspace();\n        }\n        break;\n      case 'insertCompositionText':\n        // insertCompositionText cannot be canceled.\n        // Record the current state of the element so we can restore it in the `input` event below.\n        compositionRef.current = ref.current.textContent;\n\n        // Safari gets stuck in a composition state unless we also assign to the value here.\n        // eslint-disable-next-line no-self-assign\n        ref.current.textContent = ref.current.textContent;\n        break;\n      default:\n        if (e.data != null) {\n          onInput(e.data);\n        }\n        break;\n    }\n  });\n\n  useEvent(ref, 'input', (e: InputEvent) => {\n    let {inputType, data} = e;\n    switch (inputType) {\n      case 'insertCompositionText':\n        // Reset the DOM to how it was in the beforeinput event.\n        ref.current.textContent = compositionRef.current;\n\n        // Android sometimes fires key presses of letters as composition events. Need to handle am/pm keys here too.\n        // Can also happen e.g. with Pinyin keyboard on iOS.\n        if (startsWith(am, data) || startsWith(pm, data)) {\n          onInput(data);\n        }\n        break;\n    }\n  });\n\n  useLayoutEffect(() => {\n    let element = ref.current;\n    return () => {\n      // If the focused segment is removed, focus the previous one, or the next one if there was no previous one.\n      if (document.activeElement === element) {\n        let prev = focusManager.focusPrevious();\n        if (!prev) {\n          focusManager.focusNext();\n        }\n      }\n    };\n  }, [ref, focusManager]);\n\n  // spinbuttons cannot be focused with VoiceOver on iOS.\n  let touchPropOverrides = isIOS() || segment.type === 'timeZoneName' ? {\n    role: 'textbox',\n    'aria-valuemax': null,\n    'aria-valuemin': null,\n    'aria-valuetext': null,\n    'aria-valuenow': null\n  } : {};\n\n  // Only apply aria-describedby to the first segment, unless the field is invalid. This avoids it being\n  // read every time the user navigates to a new segment.\n  let firstSegment = useMemo(() => state.segments.find(s => s.isEditable), [state.segments]);\n  if (segment !== firstSegment && !state.isInvalid) {\n    ariaDescribedBy = undefined;\n  }\n\n  let id = useId();\n  let isEditable = !state.isDisabled && !state.isReadOnly && segment.isEditable;\n\n  // Prepend the label passed from the field to each segment name.\n  // This is needed because VoiceOver on iOS does not announce groups.\n  let name = segment.type === 'literal' ? '' : displayNames.of(segment.type);\n  let labelProps = useLabels({\n    'aria-label': `${name}${ariaLabel ? `, ${ariaLabel}` : ''}${ariaLabelledBy ? ', ' : ''}`,\n    'aria-labelledby': ariaLabelledBy\n  });\n\n  // Literal segments should not be visible to screen readers. We don't really need any of the above,\n  // but the rules of hooks mean hooks cannot be conditional so we have to put this condition here.\n  if (segment.type === 'literal') {\n    return {\n      segmentProps: {\n        'aria-hidden': true\n      }\n    };\n  }\n\n  return {\n    segmentProps: mergeProps(spinButtonProps, labelProps, {\n      id,\n      ...touchPropOverrides,\n      'aria-invalid': state.isInvalid ? 'true' : undefined,\n      'aria-describedby': ariaDescribedBy,\n      'aria-readonly': state.isReadOnly || !segment.isEditable ? 'true' : undefined,\n      'data-placeholder': segment.isPlaceholder || undefined,\n      contentEditable: isEditable,\n      suppressContentEditableWarning: isEditable,\n      spellCheck: isEditable ? 'false' : undefined,\n      autoCapitalize: isEditable ? 'off' : undefined,\n      autoCorrect: isEditable ? 'off' : undefined,\n      // Capitalization was changed in React 17...\n      [parseInt(React.version, 10) >= 17 ? 'enterKeyHint' : 'enterkeyhint']: isEditable ? 'next' : undefined,\n      inputMode: state.isDisabled || segment.type === 'dayPeriod' || segment.type === 'era' || !isEditable ? undefined : 'numeric',\n      tabIndex: state.isDisabled ? undefined : 0,\n      onKeyDown,\n      onFocus,\n      style: {\n        caretColor: 'transparent'\n      },\n      // Prevent pointer events from reaching useDatePickerGroup, and allow native browser behavior to focus the segment.\n      onPointerDown(e) {\n        e.stopPropagation();\n      },\n      onMouseDown(e) {\n        e.stopPropagation();\n      }\n    })\n  };\n}\n\nfunction commonPrefixLength(strings: string[]): number {\n  // Sort the strings, and compare the characters in the first and last to find the common prefix.\n  strings.sort();\n  let first = strings[0];\n  let last = strings[strings.length - 1];\n  for (let i = 0; i < first.length; i++) {\n    if (first[i] !== last[i]) {\n      return i;\n    }\n  }\n  return 0;\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}